%token<Count> NEWLINES // (\n|\r\n)+

%token<CommentGroups> COMMENT_GROUPS

%token<Value> INTEGER_LITERAL FLOAT_LITERAL RUNE_LITERAL STRING_LITERAL

// Identifiers with prefix "_" are private to the package (Note that "_" is a
// keyword, not an identifier). Nameing convention is lower camelcase for
// variables, upper camelcase for types.
%token<Value> IDENTIFIER

// "_" is a keyword that has different meanings in different context:
//  1. As an expression, it's an assignable, but inaccessible, variable
//     placeholder that can be used anywhere without val/let declaration.
//  2. As an type expression:
//    a. When used as an enum value type, the enum value has no associated data.
//    b. Everywhere else, it is an inferred mutable reference type.
%token<Value> UNDERSCORE

%token<Value> TRUE FALSE

%token<Value> IF ELSE SWITCH CASE DEFAULT FOR DO IN SELECT
%token<Value> RETURN BREAK CONTINUE FALLTHROUGH

%token<Value> PACKAGE IMPORT

%token<Value> UNSAFE

%token<Value> TYPE IMPLEMENTS STRUCT ENUM TRAIT
%token<Value> FUNC ASYNC DEFER
%token<Value> VAR LET AS

%token<Value> NOT AND OR

%token<Value> LABEL_DECL // <identifier>@
%token<Value> JUMP_LABEL // @<identifier>

%token<Value> LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET
%token<Value> DOT COMMA QUESTION SEMICOLON COLON EXCLAIM
%token<Value> DOLLAR_LBRACKET // $[
%token<Value> ELLIPSIS // ...
%token<Value> TILDE_TILDE

%token<Value> ASSIGN ARROW

%token<Value> ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN
%token<Value> ADD_ONE_ASSIGN SUB_ONE_ASSIGN
%token<Value> BIT_NEG_ASSIGN BIT_AND_ASSIGN BIT_OR_ASSIGN BIT_XOR_ASSIGN
%token<Value> BIT_LSHIFT_ASSIGN BIT_RSHIFT_ASSIGN

%token<Value> ADD SUB MUL DIV MOD
%token<Value> BIT_NEG BIT_AND BIT_XOR BIT_OR BIT_LSHIFT BIT_RSHIFT
%token<Value> EQUAL NOT_EQUAL LESS LESS_OR_EQUAL GREATER GREATER_OR_EQUAL

%token<ParseError> PARSE_ERROR

%start source definition statement expr type_expr statements

source<Definitions> ->
  = definitions

proper_definitions<Definitions> ->
  add: proper_definitions NEWLINES definition |
  definition

definitions<Definitions> ->
  = proper_definitions |
  improper: proper_definitions NEWLINES |
  nil:

definition<Definition> ->
  // There can only be at most one package_def per package
  = package_def |
  = type_def |
  = named_func_def |
  = global_var_def |
  // There can only be at most one statements per package, which act as
  // the package's init function
  = statements_or_parse_error |
  = floating_comment

// Global variable dependencies must be topologically sortable.
global_var_def<Definition> ->
  = decl_var_pattern |
  def: decl_var_pattern ASSIGN expr

// Free floating comment is not part of any other symbol. This can happen if
// the source file only has comments, or if there are comments at the end of
// the source.
floating_comment<Definition> -> COMMENT_GROUPS

//
// Statement block
//

// IMPORTANT NOTE!!!
//
// The grammar is specified in such a way that only the statements rule
// uses LBRACE and RBRACE.  Hence, we can unconditionally parse a
// statements when we encounters a LBRACE.
//
// This enables the parser to parse the source in piecemeal manner, which
// enables the parser to collect more parse errors on a single run.
//
// Post analysis is needed to ensure statements are valid for the specific
// context.
//
// Note: statements's value type can be either the statements's
// real value type, i.e., *StatementsExpr, or PARSE_ERROR's value type,
// i.e., *ParseErrorSymbol
statements<Expression> -> LBRACE statement_list RBRACE

statements_or_parse_error<Expression> ->
  = statements |
  = parse_error_expr

proper_statement_list<StatementsExpr> ->
  add_implicit: proper_statement_list NEWLINES statement |
  add_explicit: proper_statement_list SEMICOLON statement |
  statement

statement_list<StatementsExpr> ->
  = proper_statement_list |
  improper_implicit: proper_statement_list NEWLINES |
  improper_explicit: proper_statement_list SEMICOLON |
  nil:

// The subset of simple statement that is usable within a traditional style
// for loop (plus the option to not have any statement).  In particular, the
// subset does not include any branching expressions.
sequence_statement<Statement> ->
  = unsafe_statement |
  = sequence_expr |
  = sequence_expr_assign_statement |
  = unary_op_assign_statement |
  = binary_op_assign_statement

simple_statement<Statement> ->
  = unsafe_statement |

  = expr_or_improper_expr_struct |

  // NOTE: Only applicable in expression blocks
  = jump_statement |

  // NOTE: variable declaration without assignment is parsed as an expression.
  //
  // NOTE: package level assign pattern must be a var/let declaration
  = expr_assign_statement |

  // NOTE: assignment can only operate on proper address values.  Additional
  // checks are applied during post analysis.
  //
  // NOTE: Only applicable in expression block
  = unary_op_assign_statement |
  = binary_op_assign_statement |

  // NOTE: Only applicable to package_def
  = import_statement

statement<Statement> ->
  = simple_statement |
  = branch_statement

branch_statement<Statement> ->
  // NOTE: case_branch and default_branch are applicable only to switch and
  // select expression blocks. select_assign_recv_branch and
  // select_assign_send_bracnh are only applicable to select expression.
  // Post analysis is needed to associate statements to cases (move trailing
  // non-case statements into case's data structure).
  case_branch: CASE case_patterns COLON trailing_simple_statement |
  default_branch: DEFAULT COLON trailing_simple_statement

trailing_simple_statement<StatementsExpr> ->
  simple_statement |
  nil:

//
// expression / improper struct statement
//

// Sadly, we need two sets of rules to parse identical things.  Statement
// must use the expr variant whereas expression must use the sequence_expr
// variant.

expr_or_improper_expr_struct<Expression> ->
  = expr |
  = improper_expr_struct

// improper in the sense that the expression list is not bounded by '(' and ')'

improper_sequence_expr_struct<ImplicitStruct> ->
  pair: sequence_expr COMMA sequence_expr |
  add: improper_sequence_expr_struct COMMA sequence_expr

improper_expr_struct<ImplicitStruct> ->
  pair: expr COMMA expr |
  add: improper_expr_struct COMMA expr

//
// Unsafe statement
//

// escape hatch to get a basic compiler/transpiler running.
// unsafe<go> "emit verbatim go source"
unsafe_statement<UnsafeStatement> ->
  UNSAFE LESS IDENTIFIER GREATER STRING_LITERAL

//
// Jump / fallthrough statements
//

jump_statement<Statement> ->
  unlabeled_no_value: jump_op |
  unlabeled_valued: jump_op expr_or_improper_expr_struct |
  labeled_no_value: jump_op JUMP_LABEL |
  labeled_valued: jump_op JUMP_LABEL expr_or_improper_expr_struct |
  // Only applicable to switch case block (must be the last statement in the
  // case branch)
  FALLTHROUGH

jump_op<Value> ->
  = RETURN |
  = BREAK |
  = CONTINUE

//
// Assignment statements
//


sequence_expr_assign_statement<Statement> ->
  sequence_expr_assign_pattern ASSIGN expr

expr_assign_statement<Statement> -> expr_assign_pattern ASSIGN expr

unary_op_assign_statement<Statement> -> accessible_expr unary_op_assign

unary_op_assign<Value> ->
  = ADD_ONE_ASSIGN |
  = SUB_ONE_ASSIGN

binary_op_assign_statement<Statement> -> accessible_expr binary_op_assign expr

binary_op_assign<Value> ->
  = ADD_ASSIGN |
  = SUB_ASSIGN |
  = MUL_ASSIGN |
  = DIV_ASSIGN |
  = MOD_ASSIGN |
  = BIT_NEG_ASSIGN |
  = BIT_AND_ASSIGN |
  = BIT_OR_ASSIGN |
  = BIT_XOR_ASSIGN |
  = BIT_LSHIFT_ASSIGN |
  = BIT_RSHIFT_ASSIGN

//
// Import statement
//

import_statement<Statement> ->
  single: IMPORT import_clause |
  multiple: IMPORT LPAREN import_clauses RPAREN

proper_import_clauses<ImportStatement> ->
  add_implicit: proper_import_clauses NEWLINES import_clause |
  add_explicit: proper_import_clauses COMMA import_clause |
  import_clause

import_clauses<ImportStatement> ->
  = proper_import_clauses |
  implicit: proper_import_clauses NEWLINES |
  explicit: proper_import_clauses COMMA

import_clause<ImportClause> ->
  STRING_LITERAL |
  alias: IDENTIFIER STRING_LITERAL |
  unusable_import: UNDERSCORE STRING_LITERAL |
  import_to_local: DOT STRING_LITERAL

//
// Variable declaration pattern (Pseudo expression) ===========================
//

// VAR declares a reassignable variable. LET declares a non-reassignable
// variable.  A "constant" is a LET variable associated with a type with no
// public access to fields, and no mutation methods.
decl_var_pattern<Expression> ->
  inferred: var_type var_pattern |
  typed: var_type var_pattern type_expr

// Case pattern need to disambiguate between using a variable for pattern
// matching vs assigning values to variables (This is optional in assign
// statement since it's unambiguous)
assign_var_pattern<Expression> -> GREATER var_pattern

var_type<Value> ->
  = VAR |
  = LET

var_pattern<Expression> ->
  = named_expr |
  = tuple_pattern

tuple_pattern<Expression> -> LPAREN field_var_patterns RPAREN

proper_field_var_patterns<ArgumentList> ->
  field_var_pattern |
  add: proper_field_var_patterns COMMA field_var_pattern

field_var_patterns<ArgumentList> ->
  = proper_field_var_patterns |
  improper: proper_field_var_patterns COMMA

field_var_pattern<Argument> ->
  positional: var_pattern |
  named_assignment: IDENTIFIER ASSIGN var_pattern |
  skip_pattern: ELLIPSIS

// NOTE: *_expr_assign_pattern captures identifier and tuple vars, as well as
// fully evaluated expressions.  Additional post analysis checks are needed to
// reject invalid usage, depending on the context (e.g., assignment should
// only allow identifier expressions)

sequence_expr_assign_pattern<Expression> ->
  = sequence_expr |
  = improper_sequence_expr_struct

expr_assign_pattern<Expression> ->
  = expr_or_improper_expr_struct

case_patterns<ExpressionList> ->
  // In select expr, must verify the list has exactly one recv or send
  // expression.
  = switchable_case_patterns |
  case_assign_pattern

// case_assign_pattern has two distinct semantic usage
//
// When used in a select statement, switchable_case_patterns must be an
// valid assign_pattern and sequence_expr must be either a send_expr or an
// recv_expr.
//
// When used in a if case condition, the sequence_expr is matched against
// the switchable_case_patterns.
case_assign_pattern<CaseAssignPattern> ->
  switchable_case_patterns ASSIGN sequence_expr

switchable_case_patterns<ExpressionList> ->
  switchable_case_pattern |
  add: switchable_case_patterns COMMA switchable_case_pattern

// REMINDER TO SELF: allow top level decl_var_pattern to conditionally
// type match rather than type check error. e.g.,
//
// type Expression trait {...}
//
// var expr Expression = ...
//
// select expr {
// case var unary UnaryExpr:
//   // expr is a UnaryExpr.  Since the specified type is UnaryExpr instead of
//   // &UnaryExpr, make a copy of the expr and assign the copy to variable
//   // unary
// case var (Left=leftExpr, Right=rightExpr, ...) BinaryExpr:
//   // expr is a BinaryExpr.  Since the specified type is BinaryExpr instead
//   // of &BinaryExpr, make a copy of the expr and assign the copy's Left and
//   // Right fields to variables leftExpr and rightExpr.
// case var ifExprRef &IfExpr:
//   // expr is an IfExpr.  Since the specified type is &IfExpr, expr and
//   // ifExprRef refers to the same object.
// }
switchable_case_pattern<Expression> ->
  = expr |
  = case_enum_pattern

case_enum_pattern<Expression> ->
  // Note: parsing VAR <pkg>.<enum type>.<enum value>(...) is painful using
  // context free grammar (e.g, need to make VAR a prefix op expression instead
  // of decl_var_pattern), hence we won't support this form. (the expression
  // actually parses explicit enum match pattern, where VARs are inside the
  // data list, but we should reject this form for consistency)
  enum_match_pattern: DOT IDENTIFIER implicit_struct_expr |
  enum_nondata_match_patten: DOT IDENTIFIER |
  enum_decl_var_pattern: var_type DOT IDENTIFIER tuple_pattern

//
// Expressions ================================================================
//

expr<Expression> ->
  = if_expr |
  = switch_expr |
  = loop_expr |
  = sequence_expr |
  = select_expr

//
// Sequence control flow expression
//

sequence_expr<Expression> ->
  = send_recv_expr |
  // NOTE: *_pattern are not a real expression.  Unexpected usage in real
  // expressions are rejected during type checking.
  = decl_var_pattern |
  = assign_var_pattern

//
// If control flow expression
//

// NOTE: label is applied to the entire if expression rather than individual
// branches.
if_expr<Expression> ->
  unlabelled: if_else_expr |
  labelled: LABEL_DECL if_else_expr

if_else_expr<IfExpr> ->
  = if_elif_expr |
  else: if_elif_expr ELSE statements_or_parse_error

if_elif_expr<IfExpr> ->
  = if_only_expr |
  elif: if_elif_expr ELSE IF condition statements_or_parse_error

if_only_expr<IfExpr> ->
  IF condition statements_or_parse_error

condition<Expression> ->
  = sequence_expr |
  = case_assign_expr

case_assign_expr<Expression> -> CASE case_assign_pattern

//
// Switch control flow expression
//

// match patterns within the same case must all have identical variable binding

// Allow fallthrough iff the next case have identical (and fewer) variable
// bindings.
//
// e.g., OK.  y is binded to the same value
// switch val {
// case var (x, y): fallthrough
// case (_, var y): // do something
// }
//
// e.g., Not ok.  y != z
// switch val {
// case var (x, y): fallthrough
// case (_, var z): // do something
// }

switch_expr<Expression> ->
  = switch_expr_body |
  labelled: LABEL_DECL switch_expr_body

switch_expr_body<Expression> -> SWITCH sequence_expr statements_or_parse_error

//
// Select control flow expression
//

select_expr<Expression> ->
  = select_expr_body |
  labelled: LABEL_DECL select_expr_body

select_expr_body<Expression> -> SELECT statements_or_parse_error

//
// For control flow expression
//

// NOTE: Since we use {} for expression grouping, we need the extra DO keyword
// to help the parser figure out which block is the loop's body.
//
// For example, suppose the infinite loop grammar is "FOR body_expr" and
// the while loop grammar is "FOR sequence_expr body_expr".  Then the while
// loop can be interpreted as an infinite loop "FOR sequence_expr", followed by
// an sequence statement "body_expr".
loop_expr<Expression> ->
  = loop_expr_body |
  labelled: LABEL_DECL loop_expr_body

loop_expr_body<Expression> ->
  infinite: loop_body |
  do_while: loop_body FOR sequence_expr |
  while: FOR sequence_expr loop_body |
  iterator: FOR sequence_expr_assign_pattern IN sequence_expr loop_body |
  for: FOR optional_sequence_statement SEMICOLON optional_sequence_expr SEMICOLON optional_sequence_statement loop_body

optional_sequence_statement<Statement> ->
  = sequence_statement |
  nil:

optional_sequence_expr<Expression> ->
  = sequence_expr |
  nil:

loop_body<Expression> -> DO statements_or_parse_error

//
// Call expression
//

call_expr<Expression> ->
  accessible_expr generic_arguments LPAREN arguments RPAREN

proper_arguments<ArgumentList> ->
  add: proper_arguments COMMA argument |
  argument

arguments<ArgumentList> ->
  = proper_arguments |
  improper: proper_arguments COMMA |
  nil:

argument<Argument> ->
  positional: expr |
  colon_expr |
  named_assignment: IDENTIFIER ASSIGN expr |
  // XXX: Under golang-style vararg assignment, the signature f(args ...int)
  // will not accept f(0, 1, x...) where x an int slice.  Maybe relax this into
  // vararg expansion instead?
  vararg_assignment: expr ELLIPSIS |
  // NOTE: ... is not a real expression, and is only used for pattern matching.
  // Unexpected usage in real expressions are rejected during type checking.
  skip_pattern: ELLIPSIS

// An (n >= 2)-tuple expression usable only as an argument
colon_expr<ColonExpr> ->
  unit_unit_pair: COLON |
  expr_unit_pair: expr COLON |
  unit_expr_pair: COLON expr |
  expr_expr_pair: expr COLON expr |
  colon_expr_unit_tuple: colon_expr COLON |
  colon_expr_expr_tuple: colon_expr COLON expr

//
// Simple expressions (in decreasing order precedence)
//

atom_expr<Expression> ->
  = parse_error_expr |
  = literal_expr |
  = named_expr |
  = statements_expr |
  = anonymous_func_expr |
  = initialize_expr |
  = implicit_struct_expr

parse_error_expr<Expression> -> PARSE_ERROR

literal_expr<Expression> ->
  TRUE |
  FALSE |
  INTEGER_LITERAL |
  FLOAT_LITERAL |
  RUNE_LITERAL |
  STRING_LITERAL

named_expr<Expression> ->
  IDENTIFIER |
  UNDERSCORE

statements_expr<Expression> ->
  = statements |
  labelled: LABEL_DECL statements_or_parse_error

initialize_expr<Expression> -> initializable_type_expr LPAREN arguments RPAREN

implicit_struct_expr<Expression> -> LPAREN arguments RPAREN

accessible_expr<Expression> ->
  = atom_expr |
  = access_expr |
  = call_expr |
  = index_expr |
  = as_expr

access_expr<Expression> -> accessible_expr DOT IDENTIFIER

// Note: post analysis need to check to ensure argument either a positional
// or colon expressions argument.
index_expr<Expression> -> accessible_expr LBRACKET argument RBRACKET

// eqv to golang's "s, ok := expr.(SomeType)".
as_expr<Expression> -> accessible_expr DOT AS LPAREN type_expr RPAREN

postfixable_expr<Expression> ->
  = accessible_expr |
  = postfix_unary_expr

postfix_unary_op<Value> ->
  = QUESTION |
  = EXCLAIM

postfix_unary_expr<Expression> -> accessible_expr postfix_unary_op

prefixable_expr<Expression> ->
  = postfixable_expr |
  = prefix_unary_expr

prefix_unary_expr<Expression> -> prefix_unary_op prefixable_expr

prefix_unary_op<Value> ->
  = NOT |
  = BIT_NEG |
  = SUB |
  // "deref" copies an lvalue object.  The reference can be either mutable or
  // immutable.
  = MUL |
  // "ref" returns a mutable reference to the lvalue object.  ref-ing can be
  // applied on either mutable or immutable referenced location.
  = BIT_AND |
  // async eval to an await handler, whereas eval to returns unit.  The
  // prefixable_expr must be a callable expr.
  //
  // XXX: make defer's call_expr run on the nearest scope exit rather
  // than on function scope exit.  Transpiling this semantic using golang's
  // defer be annoying since golang's defer operate on function rather than
  // scope exit.  Maybe just code gen the defer call on every exit point
  // instead of relying on golang's defer?
  //
  // Need to ensure this an actual function call, not a struct initialization.
  // XXX: maybe allow async to use pseudo-call such as struct initialization?
  //
  // NOTE: compiler should optimize away the async await handler if it's not
  // used.
  //
  // NOTE: call_expr's accessible_expr and its arguments are evaluated
  // immediately. Only the call itself is applicable to the callback_op.
  = ASYNC |
  = DEFER

mul_expr<Expression> ->
  = prefixable_expr |
  = binary_mul_expr

binary_mul_expr<Expression> -> mul_expr mul_op prefixable_expr

mul_op<Value> ->
  = MUL |
  = DIV |
  = MOD |
  = BIT_AND |
  = BIT_LSHIFT |
  = BIT_RSHIFT

add_expr<Expression> ->
  = mul_expr |
  = binary_add_expr

binary_add_expr<Expression> -> add_expr add_op mul_expr

add_op<Value> ->
  = ADD |
  = SUB |
  = BIT_OR |
  = BIT_XOR

cmp_expr<Expression> ->
  = add_expr |
  = binary_cmp_expr

binary_cmp_expr<Expression> -> cmp_expr cmp_op add_expr

cmp_op<Value> ->
  = EQUAL |
  = NOT_EQUAL |
  = LESS |
  = LESS_OR_EQUAL |
  = GREATER |
  = GREATER_OR_EQUAL

and_expr<Expression> ->
  = cmp_expr |
  = binary_and_expr

binary_and_expr<Expression> -> and_expr AND cmp_expr

or_expr<Expression> ->
  = and_expr |
  = binary_or_expr

binary_or_expr<Expression> -> or_expr OR and_expr

send_recv_expr<Expression> ->
  = or_expr |
  = send_expr |
  = recv_expr

send_expr<Expression> -> send_recv_expr ARROW or_expr

recv_expr<Expression> -> ARROW or_expr

//
// Types ======================================================================
//

// Note: named type initializations are parsed as call_expr instead of
// initialize_expr
initializable_type_expr<TypeExpression> ->
  = explicit_struct_type_expr |
  = slice_type_expr |
  = array_type_expr |
  = map_type_expr

// shorthand for Slice$[ <type_expr> ]
slice_type_expr<TypeExpression> -> LBRACKET type_expr RBRACKET

array_type_expr<TypeExpression> ->
  LBRACKET type_expr COMMA INTEGER_LITERAL RBRACKET

// shorthand for Map$[ <type_expr> , <type_expr> ]
map_type_expr<TypeExpression> -> LBRACKET type_expr COLON type_expr RBRACKET

atom_type_expr<TypeExpression> ->
  = initializable_type_expr |
  = named_type_expr |
  = inferred_type_expr |
  = implicit_struct_type_expr |
  = explicit_enum_type_expr |
  = implicit_enum_type_expr |
  = trait_type_expr |
  = func_type_expr

named_type_expr<TypeExpression> ->
  local: IDENTIFIER generic_arguments |
  external: IDENTIFIER DOT IDENTIFIER generic_arguments

// NOTE: "." infers to a copy-on-mutate reference by default, whereas "_"
// infers to a mutable reference by default (or a non-data enum value).
//
// NOTE: Maybe allow "DOT generic_arguments", which potentially only infer
// a name rather than a type_expr.
inferred_type_expr<TypeExpression> ->
  DOT |
  UNDERSCORE

// NOTE: allowing return type to use trait algebra without explicitly wrapping
// inside a trait() would cause to ambiguity.  e.g.,
// "func() A + B" could mean func() returning "A + B" or "func() A" + "B"
returnable_type_expr<TypeExpression> ->
  = atom_type_expr |
  = prefix_unary_type_expr

prefix_unary_type_expr<TypeExpression> ->
  prefix_unary_type_op returnable_type_expr

prefix_unary_type_op<Value> ->
  = QUESTION | // shorthand for Optional$[ <atom_type_expr> ]
  = EXCLAIM | // shorthand for Result$[ <atom_type_expr> ]
  = BIT_AND | // reference type
  = BIT_NEG | // type's public method signatures trait
  = TILDE_TILDE // type's public method signatures and fields trait

// NOTE: use explicit trait() to specify op precedence e.g.,
// trait( trait(A+B) * C)
type_expr<TypeExpression> ->
  = returnable_type_expr |
  = binary_type_expr

binary_type_expr<TypeExpression> ->
  type_expr binary_type_op returnable_type_expr

binary_type_op<Value> ->
  = MUL | // trait intersect
  = ADD | // trait union
  = SUB // trait difference

type_def<Definition> ->
  definition: TYPE IDENTIFIER generic_parameters type_expr |
  constrained_def: TYPE IDENTIFIER generic_parameters type_expr IMPLEMENTS type_expr |
  alias: TYPE IDENTIFIER ASSIGN type_expr

//
// Generic parameter definitions / arguments
//

// XXX: allow default generic parameter value?
generic_parameter<GenericParameter> ->
  unconstrained: IDENTIFIER |
  constrained: IDENTIFIER type_expr

generic_parameters<GenericParameterList> ->
  generic: DOLLAR_LBRACKET generic_parameter_list RBRACKET |
  nil:

proper_generic_parameter_list<GenericParameterList> ->
  add: proper_generic_parameter_list COMMA generic_parameter |
  generic_parameter

generic_parameter_list<GenericParameterList> ->
  = proper_generic_parameter_list |
  improper: proper_generic_parameter_list COMMA |
  nil:

generic_arguments<GenericArgumentList> ->
  binding: DOLLAR_LBRACKET generic_argument_list RBRACKET |
  nil:

proper_generic_argument_list<GenericArgumentList> ->
  add: proper_generic_argument_list COMMA type_expr |
  type_expr

generic_argument_list<GenericArgumentList> ->
  = proper_generic_argument_list |
  improper: proper_generic_argument_list COMMA |
  nil:

//
// Explicit/Implicit struct/enum/trait definition
//

field_def<FieldDef> ->
  named: IDENTIFIER type_expr |
  unnamed: type_expr

// NOTE: default_enum_field_def is only usable in enum.  method_signature is
// only usable in trait.  struct_padding is only usable in struct.
// These are checked post parsing.
//
// NOTE: In general, type_expr must be concrete (i.e., can't have any inferred
// type).  Enum value can use "_" as type to indicate no data is associated
// with the enum value.
type_property<TypeProperty> ->
  = field_def |
  default_enum_field_def: DEFAULT field_def |
  padding_field_def: UNDERSCORE type_expr |
  = method_signature |
  = unsafe_statement

proper_implicit_type_properties<TypeProperties> ->
  add: proper_implicit_type_properties COMMA type_property |
  type_property

implicit_type_properties<TypeProperties> ->
  = proper_implicit_type_properties |
  improper: proper_implicit_type_properties COMMA |
  nil:

implicit_struct_type_expr<TypeExpression> ->
  LPAREN implicit_type_properties RPAREN

proper_explicit_type_properties<TypeProperties> ->
  add_implicit: proper_explicit_type_properties NEWLINES type_property |
  add_explicit: proper_explicit_type_properties COMMA type_property |
  type_property

explicit_type_properties<TypeProperties> ->
  = proper_explicit_type_properties |
  improper_implicit: proper_explicit_type_properties NEWLINES |
  improper_explicit: proper_explicit_type_properties COMMA |
  nil:

explicit_struct_type_expr<TypeExpression> ->
  STRUCT LPAREN explicit_type_properties RPAREN

trait_type_expr<TypeExpression> ->
  TRAIT LPAREN explicit_type_properties RPAREN

// NOTE: inferred "<type_expr> OR ()" should be treated as
// Optional$[<type_expr>]
//
// NOTE: inferred "<type_expr> OR Error" should be treated as
// Result$[<type_expr>]
//
// NOTE: inferred types "<type_expr> OR Error or ()" (in any order) should be
// treated as Result$[ Optional$[ <type_expr> ] ]
proper_implicit_enum_type_properties<TypeProperties> ->
  pair: type_property OR type_property |
  add: proper_implicit_enum_type_properties OR type_property

implicit_enum_type_properties<TypeProperties> ->
  = proper_implicit_enum_type_properties |
  // allow ) on a different line
  improper: proper_implicit_enum_type_properties NEWLINES

implicit_enum_type_expr<TypeExpression> ->
  LPAREN implicit_enum_type_properties RPAREN

proper_explicit_enum_type_properties<TypeProperties> ->
  explicit_pair: type_property OR type_property |
  implicit_pair: type_property NEWLINES type_property |
  explicit_add: proper_explicit_enum_type_properties OR type_property |
  implicit_add: proper_explicit_enum_type_properties NEWLINES type_property

explicit_enum_type_properties<TypeProperties> ->
  = proper_explicit_enum_type_properties |
  // allow ) on a different line
  improper: proper_explicit_enum_type_properties NEWLINES

explicit_enum_type_expr<TypeExpression> ->
  ENUM LPAREN explicit_enum_type_properties RPAREN

//
// Function type, definition, trait method signature
// and anonymous func expression
//

return_type<TypeExpression> ->
  = returnable_type_expr |
  nil:

proper_parameter_def<Parameter> ->
  named_typed_arg: IDENTIFIER type_expr |
  named_typed_vararg: IDENTIFIER ELLIPSIS type_expr |
  named_inferred_vararg: IDENTIFIER ELLIPSIS |
  ignore_typed_arg: UNDERSCORE type_expr |
  ignore_inferred_vararg: UNDERSCORE ELLIPSIS |
  ignore_typed_vararg: UNDERSCORE ELLIPSIS type_expr

// NOTE: inferred mutable reference is declared either as "_" or "IDENTIFIER _".
// copy-on-mutate reference is declared either as "." or "IDENTIFIER ."
parameter_decl<Parameter> ->
  = proper_parameter_def |
  unnamed_typed_arg: type_expr |
  unnamed_inferred_vararg: ELLIPSIS |
  unnamed_typed_vararg: ELLIPSIS type_expr

// NOTE: Parameter that don't specify any type, or has type "_",  will be
// inferred as a mutable reference by default, i.e., equivalent to "&.".
// Parameter that specify "." as its type will be inferred as copy-on-mutate
// reference by default.
parameter_def<Parameter> ->
  = proper_parameter_def |
  named_inferred_arg: IDENTIFIER |
  ignore_inferred_arg: UNDERSCORE

proper_parameter_decl_list<Parameters> ->
  add: proper_parameter_decl_list COMMA parameter_decl |
  parameter_decl

parameter_decl_list<Parameters> ->
  = proper_parameter_decl_list |
  improper: proper_parameter_decl_list COMMA |
  nil:

parameter_decls<Parameters> -> LPAREN parameter_decl_list RPAREN

proper_parameter_def_list<Parameters> ->
  add: proper_parameter_def_list COMMA parameter_def |
  parameter_def

parameter_def_list<Parameters> ->
  = proper_parameter_def_list |
  improper: proper_parameter_def_list COMMA |
  nil:

parameter_defs<Parameters> -> LPAREN parameter_def_list RPAREN

func_type_expr<TypeExpression> -> FUNC parameter_decls return_type

// NOTE: FUNC is needed to disambiguate method signature from field def.
// e.g., Foo (int, int) could mean a field named Foo with type
// struct(int, int), or a method called Foo that takes two argument if func
// is not present.
//
// XXX: allow generic parameters in method signature? No, for go transpiler.
// Ideally yes.  We should allow function overloading as long as the functions
// all conforms to the same (unconstrainted) generic parameterized signature.
// Ambiguous usage would need to explicitly specify the generic parameter.
method_signature<TypeProperty> -> FUNC IDENTIFIER parameter_decls return_type

// XXX: allow generic parameters in method definition? No, for go transpiler.
//
// Note: there's no syntactic sugar for func alias.  use
//  let <alias> = <original_func>
// instead.
named_func_def<Definition> ->
  func_def: FUNC IDENTIFIER generic_parameters parameter_defs return_type statements_or_parse_error |
  method_def: FUNC LPAREN parameter_def RPAREN IDENTIFIER parameter_defs return_type statements_or_parse_error

anonymous_func_expr<Expression> ->
  FUNC parameter_defs return_type statements_or_parse_error

//
// Package definition =========================================================
//

// NOTE: the package name is taken from the directory name.  The compiler must
// ensure the directory name is a valid IDENTIFIER.  The name cannot be
// "internal" since that's special cased by go.  As an alternative to go's
// internal, if the package name is a private, it can only be accessed by its
// parent directory package.
package_def<Definition> -> PACKAGE statements_or_parse_error

%%lang_specs{
go:
  package: lr
  value_types:
    ParseError: "ParseErrorSymbol"
    Count: "TokenCount"
    Value: "*TokenValue"
    Expression: "github.com/pattyshack/pl/ast.Expression"
    ExpressionList: "*github.com/pattyshack/pl/ast.ExpressionList"
    IfExpr: "*github.com/pattyshack/pl/ast.IfExpr"
    ColonExpr: "*github.com/pattyshack/pl/ast.ColonExpr"
    Parameter: "*github.com/pattyshack/pl/ast.Parameter"
    Parameters: "*github.com/pattyshack/pl/ast.ParameterList"
    Argument: "*github.com/pattyshack/pl/ast.Argument"
    ArgumentList: "*github.com/pattyshack/pl/ast.ArgumentList"
    TypeExpression: "github.com/pattyshack/pl/ast.TypeExpression"
    GenericParameter: "*github.com/pattyshack/pl/ast.GenericParameter"
    GenericParameterList: "*github.com/pattyshack/pl/ast.GenericParameterList"
    GenericArgumentList: "*github.com/pattyshack/pl/ast.GenericArgumentList"
    Statement: "github.com/pattyshack/pl/ast.Statement"
    StatementsExpr: "*github.com/pattyshack/pl/ast.StatementsExpr"
    Definition: "github.com/pattyshack/pl/ast.Definition"
    Definitions: "*github.com/pattyshack/pl/ast.DefinitionList"
    TypeProperty: "github.com/pattyshack/pl/ast.TypeProperty"
    TypeProperties: "*github.com/pattyshack/pl/ast.TypePropertyList"
    FieldDef: "*github.com/pattyshack/pl/ast.FieldDef"
    ImportClause: "*github.com/pattyshack/pl/ast.ImportClause"
    ImportStatement: "*github.com/pattyshack/pl/ast.ImportStatement"
    ImplicitStruct: "*github.com/pattyshack/pl/ast.ImplicitStructExpr"
    UnsafeStatement: "*github.com/pattyshack/pl/ast.UnsafeStatement"
    CaseAssignPattern: "*github.com/pattyshack/pl/ast.CaseAssignPattern"
    CommentGroups: "CommentGroupsTok"
  generate_end_pos: True
}%%
