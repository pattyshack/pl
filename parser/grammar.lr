%token<Count> NEWLINES // (\n|\r\n)+

%token<Value> COMMENT_GROUPS

%token<Value> INTEGER_LITERAL FLOAT_LITERAL RUNE_LITERAL STRING_LITERAL

// Identifiers with prefix "_" are private to the package (Note that "_" is a
// keyword, not an identifier). Nameing convention is lower camelcase for
// variables, upper camelcase for types.
%token<Value> IDENTIFIER

// "_" is a keyword that has different meanings in different context:
//  1. As an expression, it's an assignable, but inaccessible, variable
//     placeholder that can be used anywhere without val/let declaration.
//  2. As an type expression:
//    a. When used as an enum value type, the enum value has no associated data.
//    b. Everywhere else, it is an inferred mutable reference type.
%token<Value> UNDERSCORE

%token<Value> TRUE FALSE

%token<Value> IF ELSE SWITCH CASE DEFAULT FOR DO IN
%token<Value> RETURN BREAK CONTINUE FALLTHROUGH

%token<Value> PACKAGE IMPORT

%token<Value> UNSAFE

%token<Value> TYPE IMPLEMENTS STRUCT ENUM TRAIT
%token<Value> FUNC ASYNC DEFER
%token<Value> VAR LET

%token<Value> NOT AND OR

%token<Value> LABEL_DECL // <identifier>@
%token<Value> JUMP_LABEL // @<identifier>

%token<Value> LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET
%token<Value> DOT COMMA QUESTION SEMICOLON COLON EXCLAIM
%token<Value> DOLLAR_LBRACKET // $[
%token<Value> ELLIPSIS // ...
%token<Value> TILDE_TILDE

%token<Value> ASSIGN

%token<Value> ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN
%token<Value> ADD_ONE_ASSIGN SUB_ONE_ASSIGN
%token<Value> BIT_NEG_ASSIGN BIT_AND_ASSIGN BIT_OR_ASSIGN BIT_XOR_ASSIGN
%token<Value> BIT_LSHIFT_ASSIGN BIT_RSHIFT_ASSIGN

%token<Value> ADD SUB MUL DIV MOD
%token<Value> BIT_NEG BIT_AND BIT_XOR BIT_OR BIT_LSHIFT BIT_RSHIFT
%token<Value> EQUAL NOT_EQUAL LESS LESS_OR_EQUAL GREATER GREATER_OR_EQUAL

%token<ParseError> PARSE_ERROR

%start source statement expr type_expr

source<SourceDefinitions> -> definitions

proper_definitions<SourceDefinitions> ->
  add: proper_definitions NEWLINES definition |
  definition

definitions<SourceDefinitions> ->
  = proper_definitions |
  improper: proper_definitions NEWLINES |
  nil:

definition<SourceDefinition> ->
  // There can only be one package_def per package
  = package_def |
  = type_def |
  = named_func_def |
  global_var_def: var_decl_pattern |
  global_var_assignment: var_decl_pattern ASSIGN expr |
  // There can only be at most one statement_block per package, which act as
  // the package's init function
  statement_block |
  // Free floating comment groups that are not part of any other symbol.
  // This can happen if the source file only has comments, or if there are
  // comments at the end of the source.
  COMMENT_GROUPS

//
// Statement block
//

// IMPORTANT NOTE!!!
//
// The grammar is specified in such a way that only the statement_block rule
// uses LBRACE and RBRACE.  Hence, we can unconditionally parse a
// statement_block when we encounters a LBRACE.
//
// This enables the parser to parse the source in piecemeal manner, which
// enables the parser to collect more parse errors on a single run.
//
// Post analysis is needed to ensure statements are valid for the specific
// context.
//
// Note: statement_block's value type can be either the statement_block's
// real value type, or PARSE_ERROR's value type
statement_block<Expression> -> LBRACE statements RBRACE

proper_statements<Statements> ->
  add_implicit: proper_statements NEWLINES statement |
  add_explicit: proper_statements SEMICOLON statement |
  statement

statements<Statements> ->
  = proper_statements |
  improper_implicit: proper_statements NEWLINES |
  improper_explicit: proper_statements SEMICOLON |
  nil:

simple_statement<Statement> ->
  = unsafe_statement |

  = expr_or_improper_struct_statement |

  // NOTE: Only applicable in expression blocks
  = jump_statement |

  // NOTE: variable declaration without assignment is parsed as an expression.
  //
  // NOTE: package level assign pattern must be a var/let declaration
  = assign_statement |

  // NOTE: assignment can only operate on proper address values.  Additional
  // checks are applied during post analysis.
  //
  // NOTE: Only applicable in expression block
  = unary_op_assign_statement |
  = binary_op_assign_statement |

  // Only applicable to switch case block (must be the last statement in the
  // case branch)
  = fallthrough_statement

statement<Statement> ->
  = simple_statement |

  // NOTE: Only applicable to package_def
  = import_statement |

  // NOTE: Only applicable to switch case block.
  // Post analysis is needed to associate statements to cases (move trailing
  // non-case statements into case's data structure).
  case_branch_statement: CASE case_patterns COLON optional_simple_statement |
  default_branch_statement: DEFAULT COLON optional_simple_statement

optional_simple_statement<Statement> ->
  = simple_statement |
  nil:

//
// expression / improper struct statement
//

expr_or_improper_struct_statement<Statement> -> exprs

exprs ->
  expr |
  add: exprs COMMA expr

//
// Unsafe statement
//

// escape hatch to get a basic compiler/transpiler running.
// unsafe<go> "emit verbatim go source"
unsafe_statement<Statement> -> UNSAFE LESS IDENTIFIER GREATER STRING_LITERAL

//
// Jump / fallthrough statements
//

jump_statement<Statement> ->
  unlabeled_no_value: jump_type |
  unlabeled_valued: jump_type exprs |
  labeled_no_value: jump_type JUMP_LABEL |
  labeled_valued: jump_type JUMP_LABEL exprs

jump_type<Value> ->
  = RETURN |
  = BREAK |
  = CONTINUE

fallthrough_statement<Statement> -> FALLTHROUGH

//
// Assignment statements
//

assign_statement<Statement> -> assign_pattern ASSIGN expr

unary_op_assign_statement<Statement> -> accessible_expr unary_op_assign

unary_op_assign<Value> ->
  = ADD_ONE_ASSIGN |
  = SUB_ONE_ASSIGN

binary_op_assign_statement<Statement> -> accessible_expr binary_op_assign expr

binary_op_assign<Value> ->
  = ADD_ASSIGN |
  = SUB_ASSIGN |
  = MUL_ASSIGN |
  = DIV_ASSIGN |
  = MOD_ASSIGN |
  = BIT_NEG_ASSIGN |
  = BIT_AND_ASSIGN |
  = BIT_OR_ASSIGN |
  = BIT_XOR_ASSIGN |
  = BIT_LSHIFT_ASSIGN |
  = BIT_RSHIFT_ASSIGN

//
// Import statement
//

import_statement<Statement> ->
  single: IMPORT import_clause |
  multiple: IMPORT LPAREN import_clauses RPAREN

import_clause ->
  STRING_LITERAL |
  alias: IDENTIFIER STRING_LITERAL |
  unusable_import: UNDERSCORE STRING_LITERAL |
  import_to_local: DOT STRING_LITERAL

proper_import_clauses ->
  add_implicit: proper_import_clauses NEWLINES import_clause |
  add_explicit: proper_import_clauses COMMA import_clause |
  import_clause

import_clauses ->
  = proper_import_clauses |
  implicit: proper_import_clauses NEWLINES |
  explicit: proper_import_clauses COMMA

//
// Case statement
//

case_patterns ->
  case_pattern |
  multiple: case_patterns COMMA case_pattern

//
// Variable declaration pattern (Pseudo expression) ===========================
//

// VAR declares a reassignable variable. LET declares a non-reassignable
// variable.  A "constant" is a LET variable associated with a type with no
// public access to fields, and no mutation methods.
var_decl_pattern -> var_or_let var_pattern optional_type_expr

var_or_let<Value> ->
  = VAR |
  = LET

var_pattern ->
  IDENTIFIER |
  UNDERSCORE |
  tuple_pattern

tuple_pattern -> LPAREN field_var_patterns RPAREN

field_var_patterns ->
  field_var_pattern |
  add: field_var_patterns COMMA field_var_pattern

field_var_pattern ->
  positional: var_pattern |
  named: IDENTIFIER ASSIGN var_pattern |
  ELLIPSIS

optional_type_expr<TypeExpression> ->
  = type_expr |
  nil:

// NOTE: expression captures identifier and tuple vars, as well as fully
// evaluated expressions.  Additional post analysis checks are needed to
// reject invalid usage, depending on the context (e.g., assignment should
// only allow identifier expressions)
assign_pattern ->
  sequence_expr

case_pattern ->
  = assign_pattern |

  // Note: parsing VAR <pkg>.<enum type>.<enum value>(...) is painful using
  // context free grammar (e.g, need to make VAR a prefix op expression instead
  // of var_decl_pattern), hence we won't support this form. (the expression
  // actually parses explicit enum match pattern, where VARs are inside the
  // data list, but we should reject this form for consistency)
  enum_match_pattern: DOT IDENTIFIER implicit_struct_expr |
  enum_nondata_match_patten: DOT IDENTIFIER |
  enum_var_decl_pattern: VAR DOT IDENTIFIER tuple_pattern

//
// Expressions ================================================================
//

expr<Expression> ->
  = if_expr |
  = switch_expr |
  = loop_expr |
  = sequence_expr

//
// Sequence control flow expression
//

sequence_expr<Expression> ->
  = or_expr |
  // NOTE: var_decl_pattern is not a real expression.  Unexpected usage in real
  // expressions are rejected during type checking.
  var_decl_pattern |
  // Case pattern need to disambiguate between using a variable for pattern
  // matching vs assigning a value to the variable (This is optional in
  // assign_pattern since it's unambiguous)
  assign_var_pattern: GREATER sequence_expr

//
// If control flow expression
//

// NOTE: label is applied to the entire if expression rather than individual
// branches.
if_expr<Expression> ->
  unlabelled: if_else_expr |
  labelled: LABEL_DECL if_else_expr

if_else_expr<IfExpr> ->
  = if_elif_expr |
  else: if_elif_expr ELSE statement_block

if_elif_expr<IfExpr> ->
  = if_only_expr |
  elif: if_elif_expr ELSE IF condition statement_block

if_only_expr<IfExpr> ->
  IF condition statement_block

condition<Expression> ->
  sequence_expr |
  case: CASE case_patterns ASSIGN sequence_expr

//
// Switch control flow expression
//

// match patterns within the same case must all have identical variable binding

// Allow fallthrough iff the next case have identical (and fewer) variable
// bindings.
//
// e.g., OK.  y is binded to the same value
// switch val {
// case var (x, y): fallthrough
// case (_, var y): // do something
// }
//
// e.g., Not ok.  y != z
// switch val {
// case var (x, y): fallthrough
// case (_, var z): // do something
// }

// Switch need to be exhastive.
switch_expr<Expression> ->
  = switch_expr_body |
  labelled: LABEL_DECL switch_expr_body

switch_expr_body<Expression> -> SWITCH sequence_expr statement_block

//
// For control flow expression
//

// NOTE: Since we use {} for expression grouping, we need the extra DO keyword
// to help the parser figure out which block is the loop's body.
//
// For example, suppose the infinite loop grammar is "FOR body_expr" and
// the while loop grammar is "FOR sequence_expr body_expr".  Then the while
// loop can be interpreted as an infinite loop "FOR sequence_expr", followed by
// an sequence statement "body_expr".
loop_expr<Expression> ->
  = loop_expr_body |
  labelled: LABEL_DECL loop_expr_body

loop_expr_body<Expression> ->
  infinite: DO statement_block |
  do_while: DO statement_block FOR sequence_expr |
  while: FOR sequence_expr DO statement_block |
  iterator: FOR assign_pattern IN sequence_expr DO statement_block |
  for: FOR for_assignment SEMICOLON optional_sequence_expr SEMICOLON optional_sequence_expr DO statement_block

optional_sequence_expr<Expression> ->
  sequence_expr |
  nil:

for_assignment ->
  sequence_expr |
  assign: assign_pattern ASSIGN sequence_expr

//
// Call expression
//

call_expr<Expression> ->
  accessible_expr generic_arguments LPAREN arguments RPAREN

proper_arguments<ArgumentList> ->
  add: proper_arguments COMMA argument |
  argument

arguments<ArgumentList> ->
  = proper_arguments |
  improper: proper_arguments COMMA |
  nil:

argument<Argument> ->
  positional: expr |
  colon_expr |
  named_assignment: IDENTIFIER ASSIGN expr |
  // XXX: Under golang-style vararg assignment, the signature f(args ...int)
  // will not accept f(0, 1, x...) where x an int slice.  Maybe relax this into
  // vararg expansion instead?
  vararg_assignment: expr ELLIPSIS |
  // NOTE: ... is not a real expression, and is only used for pattern matching.
  // Unexpected usage in real expressions are rejected during type checking.
  skip_pattern: ELLIPSIS

// An (n >= 2)-tuple expression usable only as an argument
colon_expr<ColonExpr> ->
  unit_unit_pair: COLON |
  expr_unit_pair: expr COLON |
  unit_expr_pair: COLON expr |
  expr_expr_pair: expr COLON expr |
  colon_expr_unit_tuple: colon_expr COLON |
  colon_expr_expr_tuple: colon_expr COLON expr

//
// Simple expressions (in decreasing order precedence)
//

// TODO cast
// TODO type isa check
// TODO is check
// TODO select (via trait instead of channel)
atom_expr<Expression> ->
  = parse_error_expr |
  = literal_expr |
  = named_expr |
  = block_expr |
  = anonymous_func_expr |
  = initialize_expr |
  = implicit_struct_expr

parse_error_expr<Expression> -> PARSE_ERROR

literal_expr<Expression> ->
  TRUE |
  FALSE |
  INTEGER_LITERAL |
  FLOAT_LITERAL |
  RUNE_LITERAL |
  STRING_LITERAL

named_expr<Expression> ->
  IDENTIFIER |
  UNDERSCORE

block_expr<Expression> ->
  = statement_block |
  labelled: LABEL_DECL statement_block

initialize_expr<Expression> -> initializable_type_expr LPAREN arguments RPAREN

implicit_struct_expr<Expression> -> LPAREN arguments RPAREN

accessible_expr<Expression> ->
  = atom_expr |
  = access_expr |
  = call_expr |
  = index_expr

access_expr<Expression> -> accessible_expr DOT IDENTIFIER

// Note: post analysis need to check to ensure argument either a positional
// or colon expressions argument.
index_expr<Expression> -> accessible_expr LBRACKET argument RBRACKET

postfixable_expr<Expression> ->
  = accessible_expr |
  = postfix_unary_expr

postfix_unary_op<Value> ->
  = QUESTION |
  = EXCLAIM

postfix_unary_expr<Expression> -> accessible_expr postfix_unary_op

prefixable_expr<Expression> ->
  = postfixable_expr |
  = prefix_unary_expr

prefix_unary_expr<Expression> -> prefix_unary_op prefixable_expr

prefix_unary_op<Value> ->
  = NOT |
  = BIT_NEG |
  = SUB |
  // "deref" copies an lvalue object.  The reference can be either mutable or
  // immutable.
  = MUL |
  // "ref" returns a mutable reference to the lvalue object.  ref-ing can be
  // applied on either mutable or immutable referenced location.
  = BIT_AND |
  // async eval to an await handler, whereas eval to returns unit.  The
  // prefixable_expr must be a callable expr.
  //
  // XXX: make defer's call_expr run on the nearest scope exit rather
  // than on function scope exit.  Transpiling this semantic using golang's
  // defer be annoying since golang's defer operate on function rather than
  // scope exit.  Maybe just code gen the defer call on every exit point
  // instead of relying on golang's defer?
  //
  // Need to ensure this an actual function call, not a struct initialization.
  // XXX: maybe allow async to use pseudo-call such as struct initialization?
  //
  // NOTE: compiler should optimize away the async await handler if it's not
  // used.
  //
  // NOTE: call_expr's accessible_expr and its arguments are evaluated
  // immediately. Only the call itself is applicable to the callback_op.
  = ASYNC |
  = DEFER

mul_expr<Expression> ->
  = prefixable_expr |
  = binary_mul_expr

binary_mul_expr<Expression> -> mul_expr mul_op prefixable_expr

mul_op<Value> ->
  = MUL |
  = DIV |
  = MOD |
  = BIT_AND |
  = BIT_LSHIFT |
  = BIT_RSHIFT

add_expr<Expression> ->
  = mul_expr |
  = binary_add_expr

binary_add_expr<Expression> -> add_expr add_op mul_expr

add_op<Value> ->
  = ADD |
  = SUB |
  = BIT_OR |
  = BIT_XOR

cmp_expr<Expression> ->
  = add_expr |
  = binary_cmp_expr

binary_cmp_expr<Expression> -> cmp_expr cmp_op add_expr

cmp_op<Value> ->
  = EQUAL |
  = NOT_EQUAL |
  = LESS |
  = LESS_OR_EQUAL |
  = GREATER |
  = GREATER_OR_EQUAL

and_expr<Expression> ->
  = cmp_expr |
  = binary_and_expr

binary_and_expr<Expression> -> and_expr AND cmp_expr

or_expr<Expression> ->
  = and_expr |
  = binary_or_expr

binary_or_expr<Expression> -> or_expr OR and_expr

//
// Types ======================================================================
//

// Note: named type initializations are parsed as call_expr instead of
// initialize_expr
initializable_type_expr<TypeExpression> ->
  = explicit_struct_type_expr |
  = slice_type_expr |
  = array_type_expr |
  = map_type_expr

// shorthand for Slice$[ <type_expr> ]
slice_type_expr<TypeExpression> -> LBRACKET type_expr RBRACKET

array_type_expr<TypeExpression> ->
  LBRACKET type_expr COMMA INTEGER_LITERAL RBRACKET

// shorthand for Map$[ <type_expr> , <type_expr> ]
map_type_expr<TypeExpression> -> LBRACKET type_expr COLON type_expr RBRACKET

atom_type_expr<TypeExpression> ->
  = initializable_type_expr |
  = named_type_expr |
  = inferred_type_expr |
  = implicit_struct_type_expr |
  = explicit_enum_type_expr |
  = implicit_enum_type_expr |
  = trait_type_expr |
  = func_type_expr |
  = parse_error_type_expr

named_type_expr<TypeExpression> ->
  local: IDENTIFIER generic_arguments |
  external: IDENTIFIER DOT IDENTIFIER generic_arguments

// NOTE: "." infers to a copy-on-mutate reference by default, whereas "_"
// infers to a mutable reference by default (or a non-data enum value).
//
// NOTE: Maybe allow "DOT generic_arguments", which potentially only infer
// a name rather than a type_expr.
inferred_type_expr<TypeExpression> ->
  DOT |
  UNDERSCORE

parse_error_type_expr<TypeExpression> -> PARSE_ERROR

// NOTE: allowing return type to use trait algebra without explicitly wrapping
// inside a trait() would cause to ambiguity.  e.g.,
// "func() A + B" could mean func() returning "A + B" or "func() A" + "B"
returnable_type_expr<TypeExpression> ->
  = atom_type_expr |
  = prefix_unary_type_expr

prefix_unary_type_expr<TypeExpression> ->
  prefix_unary_type_op returnable_type_expr

prefix_unary_type_op<Value> ->
  = QUESTION | // shorthand for Optional$[ <atom_type_expr> ]
  = EXCLAIM | // shorthand for Result$[ <atom_type_expr> ]
  = BIT_AND | // reference type
  = BIT_NEG | // type's public method signatures trait
  = TILDE_TILDE // type's public method signatures and fields trait

// NOTE: use explicit trait() to specify op precedence e.g.,
// trait( trait(A+B) * C)
type_expr<TypeExpression> ->
  = returnable_type_expr |
  = binary_type_expr

binary_type_expr<TypeExpression> ->
  type_expr binary_type_op returnable_type_expr

binary_type_op<Value> ->
  = MUL | // trait intersect
  = ADD | // trait union
  = SUB // trait difference

type_def<SourceDefinition> ->
  definition: TYPE IDENTIFIER generic_parameters type_expr |
  constrained_def: TYPE IDENTIFIER generic_parameters type_expr IMPLEMENTS type_expr |
  alias: TYPE IDENTIFIER ASSIGN type_expr

//
// Generic parameter definitions / arguments
//

// XXX: allow default generic parameter value?
generic_parameter<GenericParameter> ->
  unconstrained: IDENTIFIER |
  constrained: IDENTIFIER type_expr

generic_parameters<GenericParameterList> ->
  generic: DOLLAR_LBRACKET generic_parameter_list RBRACKET |
  nil:

proper_generic_parameter_list<GenericParameterList> ->
  add: proper_generic_parameter_list COMMA generic_parameter |
  generic_parameter

generic_parameter_list<GenericParameterList> ->
  = proper_generic_parameter_list |
  improper: proper_generic_parameter_list COMMA |
  nil:

generic_arguments<GenericArgumentList> ->
  binding: DOLLAR_LBRACKET generic_argument_list RBRACKET |
  nil:

proper_generic_argument_list<GenericArgumentList> ->
  add: proper_generic_argument_list COMMA type_expr |
  type_expr

generic_argument_list<GenericArgumentList> ->
  = proper_generic_argument_list |
  improper: proper_generic_argument_list COMMA |
  nil:

//
// Explicit/Implicit struct/enum/trait definition
//

field_def<FieldDef> ->
  named: IDENTIFIER type_expr |
  unnamed: type_expr

unsafe_statement_property<TypeProperty> -> unsafe_statement

// NOTE: default_enum_field_def is only usable in enum.  method_signature is
// only usable in trait.  struct_padding is only usable in struct.
// These are checked post parsing.
//
// NOTE: In general, type_expr must be concrete (i.e., can't have any inferred
// type).  Enum value can use "_" as type to indicate no data is associated
// with the enum value.
type_property<TypeProperty> ->
  = field_def |
  default_enum_field_def: DEFAULT field_def |
  padding_field_def: UNDERSCORE type_expr |
  = method_signature |
  = unsafe_statement_property

proper_implicit_type_properties<TypeProperties> ->
  add: proper_implicit_type_properties COMMA type_property |
  type_property

implicit_type_properties<TypeProperties> ->
  = proper_implicit_type_properties |
  improper: proper_implicit_type_properties COMMA |
  nil:

implicit_struct_type_expr<TypeExpression> ->
  LPAREN implicit_type_properties RPAREN

proper_explicit_type_properties<TypeProperties> ->
  add_implicit: proper_explicit_type_properties NEWLINES type_property |
  add_explicit: proper_explicit_type_properties COMMA type_property |
  type_property

explicit_type_properties<TypeProperties> ->
  = proper_explicit_type_properties |
  improper_implicit: proper_explicit_type_properties NEWLINES |
  improper_explicit: proper_explicit_type_properties COMMA |
  nil:

explicit_struct_type_expr<TypeExpression> ->
  STRUCT LPAREN explicit_type_properties RPAREN

trait_type_expr<TypeExpression> ->
  TRAIT LPAREN explicit_type_properties RPAREN

// NOTE: inferred "<type_expr> OR ()" should be treated as
// Optional$[<type_expr>]
//
// NOTE: inferred "<type_expr> OR Error" should be treated as
// Result$[<type_expr>]
//
// NOTE: inferred types "<type_expr> OR Error or ()" (in any order) should be
// treated as Result$[ Optional$[ <type_expr> ] ]
proper_implicit_enum_type_properties<TypeProperties> ->
  pair: type_property OR type_property |
  add: proper_implicit_enum_type_properties OR type_property

implicit_enum_type_properties<TypeProperties> ->
  = proper_implicit_enum_type_properties |
  // allow ) on a different line
  improper: proper_implicit_enum_type_properties NEWLINES

implicit_enum_type_expr<TypeExpression> ->
  LPAREN implicit_enum_type_properties RPAREN

proper_explicit_enum_type_properties<TypeProperties> ->
  explicit_pair: type_property OR type_property |
  implicit_pair: type_property NEWLINES type_property |
  explicit_add: proper_explicit_enum_type_properties OR type_property |
  implicit_add: proper_explicit_enum_type_properties NEWLINES type_property

explicit_enum_type_properties<TypeProperties> ->
  = proper_explicit_enum_type_properties |
  // allow ) on a different line
  improper: proper_explicit_enum_type_properties NEWLINES

explicit_enum_type_expr<TypeExpression> ->
  ENUM LPAREN explicit_enum_type_properties RPAREN

//
// Function type, definition, trait method signature
// and anonymous func expression
//

return_type<TypeExpression> ->
  = returnable_type_expr |
  nil:

proper_parameter_def<Parameter> ->
  named_typed_arg: IDENTIFIER type_expr |
  named_typed_vararg: IDENTIFIER ELLIPSIS type_expr |
  named_inferred_vararg: IDENTIFIER ELLIPSIS |
  ignore_typed_arg: UNDERSCORE type_expr |
  ignore_inferred_vararg: UNDERSCORE ELLIPSIS |
  ignore_typed_vararg: UNDERSCORE ELLIPSIS type_expr

// NOTE: inferred mutable reference is declared either as "_" or "IDENTIFIER _".
// copy-on-mutate reference is declared either as "." or "IDENTIFIER ."
parameter_decl<Parameter> ->
  = proper_parameter_def |
  unnamed_typed_arg: type_expr |
  unnamed_inferred_vararg: ELLIPSIS |
  unnamed_typed_vararg: ELLIPSIS type_expr

// NOTE: Parameter that don't specify any type, or has type "_",  will be
// inferred as a mutable reference by default, i.e., equivalent to "&.".
// Parameter that specify "." as its type will be inferred as copy-on-mutate
// reference by default.
parameter_def<Parameter> ->
  = proper_parameter_def |
  named_inferred_arg: IDENTIFIER |
  ignore_inferred_arg: UNDERSCORE

proper_parameter_decl_list<Parameters> ->
  add: proper_parameter_decl_list COMMA parameter_decl |
  parameter_decl

parameter_decl_list<Parameters> ->
  = proper_parameter_decl_list |
  improper: proper_parameter_decl_list COMMA |
  nil:

parameter_decls<Parameters> -> LPAREN parameter_decl_list RPAREN

proper_parameter_def_list<Parameters> ->
  add: proper_parameter_def_list COMMA parameter_def |
  parameter_def

parameter_def_list<Parameters> ->
  = proper_parameter_def_list |
  improper: proper_parameter_def_list COMMA |
  nil:

parameter_defs<Parameters> -> LPAREN parameter_def_list RPAREN

func_type_expr<TypeExpression> -> FUNC parameter_decls return_type

// NOTE: FUNC is needed to disambiguate method signature from field def.
// e.g., Foo (int, int) could mean a field named Foo with type
// struct(int, int), or a method called Foo that takes two argument if func
// is not present.
//
// XXX: allow generic parameters in method signature? No, for go transpiler.
// Ideally yes.  We should allow function overloading as long as the functions
// all conforms to the same (unconstrainted) generic parameterized signature.
// Ambiguous usage would need to explicitly specify the generic parameter.
method_signature<TypeProperty> -> FUNC IDENTIFIER parameter_decls return_type

// XXX: allow generic parameters in method definition? No, for go transpiler.
//
// Note: there's no syntactic sugar for func alias.  use
//  let <alias> = <original_func>
// instead.
named_func_def<SourceDefinition> ->
  func_def: FUNC IDENTIFIER generic_parameters parameter_defs return_type statement_block |
  method_def: FUNC LPAREN parameter_def RPAREN IDENTIFIER parameter_defs return_type statement_block

anonymous_func_expr<Expression> ->
  FUNC parameter_defs return_type statement_block

//
// Package definition =========================================================
//

// NOTE: the package name is taken from the directory name.  The compiler must
// ensure the directory name is a valid IDENTIFIER.  The name cannot be
// "internal" since that's special cased by go.  As an alternative to go's
// internal, if the package name is a private, it can only be accessed by its
// parent directory package.
package_def<SourceDefinition> ->
  no_spec: PACKAGE |
  with_spec: PACKAGE statement_block

%%lang_specs{
go:
  package: parser
  value_types:
    ParseError: "ParseErrorSymbol"
    Count: "TokenCount"
    Value: "TokenValue"
    Expression: "Expression"
    IfExpr: "*IfExpr"
    ColonExpr: "*ColonExpr"
    Parameter: "*Parameter"
    Parameters: "*ParameterList"
    Argument: "*Argument"
    ArgumentList: "*ArgumentList"
    TypeExpression: "TypeExpression"
    GenericParameter: "*GenericParameter"
    GenericParameterList: "*GenericParameterList"
    GenericArgumentList: "*GenericArgumentList"
    Statement: "Statement"
    Statements: "*StatementList"
    SourceDefinition: "SourceDefinition"
    SourceDefinitions: "[]SourceDefinition"
    TypeProperty: "TypeProperty"
    TypeProperties: "*TypePropertyList"
    FieldDef: "*FieldDef"
  generate_end_pos: True
}%%
