%token SPACES // [ \t]+
%token NEWLINES // (\n|\r\n)+

%token COMMENT // //-style or block-style comment

%token INTEGER_LITERAL FLOAT_LITERAL RUNE_LITERAL STRING_LITERAL

%token IDENTIFIER
%token TRUE FALSE
%token IF ELSE SWITCH CASE DEFAULT FOR
%token RETURN BREAK CONTINUE

%token PACKAGE

%token UNSAFE

%token TYPE STRUCT ENUM TRAIT IMPLEMENTS
%token FUNC ASYNC

%token LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET
%token DOT COMMA QUESTION SEMICOLON // COLON
%token DOLLAR_LBRACKET // $[
%token DOTDOTDOT // ...
%token TILDE_TILDE

%token LABEL_DECL // <identifier>@
%token JUMP_LABEL // @<identifier>

%token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN
%token ADD_ONE_ASSIGN SUB_ONE_ASSIGN
%token BIT_NEG_ASSIGN BIT_AND_ASSIGN BIT_OR_ASSIGN BIT_XOR_ASSIGN
%token BIT_LSHIFT_ASSIGN BIT_RSHIFT_ASSIGN

%token NOT AND OR
%token ADD SUB MUL DIV MOD
%token BIT_NEG BIT_AND BIT_XOR BIT_OR BIT_LSHIFT BIT_RSHIFT
%token EQUAL NOT_EQUAL LESS LESS_OR_EQUAL GREATER GREATER_OR_EQUAL

%token LEX_ERROR

%type optional_label_decl optional_jump_label

%type literal

%type expression
%type block_body block_expr
%type sequence_expr if_expr switch_expr loop_expr

%type anonymous_struct_expr

%type call_expr

// expression in decreasing precedence
%type atom_expr access_expr
%type postfix_unary_expr prefix_unary_expr
%type mul_expr add_expr cmp_expr and_expr or_expr

%type jump_type
%type statement statement_body unsafe_statement
%type statements

%type prefix_unary_op  // - ~ not * &
%type mul_op // * / % & << >>
%type add_op // + - | ^
%type cmp_op // == != < <= > >=

%type op_one_assign  // ++ --
%type binary_op_assign // += -= etc.

%type generic_arguments optional_generic_arguments optional_generic_binding

%type generic_parameter_def
%type generic_parameter_defs optional_generic_parameter_defs
%type optional_generic_parameters

%type argument arguments optional_arguments
%type expression_or_implicit_struct optional_expression_or_implicit_struct

%type lex_internal_tokens

%type type_def
%type value_type atom_type traitable_type trait_mul_type trait_add_type

%type explicit_enum_type implicit_enum_type
%type field_def_or_list

%type explicit_struct_def implicit_struct_def
%type field_def
%type field_defs optional_field_defs


%type trait_def
%type trait_property trait_properties optional_trait_properties

%type func_type named_func_def method_signature anonymous_func_expr
%type return_type
%type parameter_decl
%type parameter_decls optional_parameter_decls
%type parameter_def
%type parameter_defs optional_parameter_defs
%type optional_receiver

%type package_def
%type package_statement package_statement_body
%type package_statements

%start package_def type_def trait_def named_func_def expression lex_internal_tokens

literal ->
  TRUE |
  FALSE |
  INTEGER_LITERAL |
  FLOAT_LITERAL |
  RUNE_LITERAL |
  STRING_LITERAL

anonymous_struct_expr ->
  explicit: explicit_struct_def LPAREN arguments RPAREN |
  implicit: LPAREN arguments RPAREN

// TODO cast
// TODO type isa check
// TODO is check
atom_expr ->
  literal |
  IDENTIFIER |
  block_expr |
  anonymous_func_expr |
  anonymous_struct_expr |
  LEX_ERROR

// XXX allow named generic argument?
generic_arguments ->
  value_type |
  add: generic_arguments COMMA value_type

optional_generic_arguments ->
  generic_arguments |
  nil:

optional_generic_binding ->
  binding: DOLLAR_LBRACKET optional_generic_arguments RBRACKET |
  nil:

// TODO, named arugments, associative ":" tuples
argument ->
  positional: expression

arguments ->
  argument |
  add: arguments COMMA argument

optional_arguments ->
  arguments |
  nil:

call_expr -> access_expr optional_generic_binding LPAREN optional_arguments RPAREN

access_expr ->
  atom_expr |
  access: access_expr DOT IDENTIFIER |
  call_expr |
  // TODO allow ranged lookup? e.g., x[:]
  index: access_expr LBRACKET expression RBRACKET

postfix_unary_expr ->
  access_expr |
  question: access_expr QUESTION

prefix_unary_op ->
  NOT |
  BIT_NEG |
  SUB |
  // "deref" copies an lvalue object.  The reference can be either mutable or
  // immutable.
  MUL |
  // "ref" returns a mutable reference to the lvalue object.  ref-ing can be
  // applied on either mutable or immutable referenced location.
  BIT_AND

prefix_unary_expr ->
  postfix_unary_expr |
  prefix_op: prefix_unary_op prefix_unary_expr

mul_op ->
  MUL |
  DIV |
  MOD |
  BIT_AND |
  BIT_LSHIFT |
  BIT_RSHIFT

mul_expr ->
  prefix_unary_expr |
  op: mul_expr mul_op prefix_unary_expr

add_op ->
  ADD |
  SUB |
  BIT_OR |
  BIT_XOR

add_expr ->
  mul_expr |
  op: add_expr add_op mul_expr

cmp_op ->
  EQUAL |
  NOT_EQUAL |
  LESS |
  LESS_OR_EQUAL |
  GREATER |
  GREATER_OR_EQUAL

cmp_expr ->
  add_expr |
  op: cmp_expr cmp_op add_expr

and_expr ->
  cmp_expr |
  op: and_expr AND cmp_expr

or_expr ->
  and_expr |
  op: or_expr OR and_expr

sequence_expr -> or_expr

optional_jump_label ->
  JUMP_LABEL |
  unlabelled:

optional_expression_or_implicit_struct ->
  expression_or_implicit_struct |
  nil:

jump_type ->
  RETURN |
  BREAK |
  CONTINUE

op_one_assign ->
  ADD_ONE_ASSIGN |
  SUB_ONE_ASSIGN

binary_op_assign ->
  ADD_ASSIGN |
  SUB_ASSIGN |
  MUL_ASSIGN |
  DIV_ASSIGN |
  MOD_ASSIGN |
  BIT_NEG_ASSIGN |
  BIT_AND_ASSIGN |
  BIT_OR_ASSIGN |
  BIT_XOR_ASSIGN |
  BIT_LSHIFT_ASSIGN |
  BIT_RSHIFT_ASSIGN

expression_or_implicit_struct ->
  expression |
  implicit_struct: expression_or_implicit_struct COMMA expression

// escape hatch to get a basic compiler/transpiler running.
// unsafe<go> "emit verbatim go source"
unsafe_statement -> UNSAFE LESS IDENTIFIER GREATER STRING_LITERAL

statement_body ->
  unsafe_statement |

  expression_or_implicit_struct |

  async: ASYNC call_expr |  // returns an await handler
  // - compiler should optimize away the await handler if it's not used.

  jump: jump_type optional_jump_label optional_expression_or_implicit_struct |

  // TODO assignment. something like
  // var <variable pattern> = [optional ASYNC] expression
  //
  // var fixed x = 5
  // x is not reassignable after initial assignment.
  // if x behaves like a constant if the object reference is immutable, and no
  // field are publically accessible.

  // NOTE: both op_one_assign and binary_op_assign can only operate on
  // proper address values.  Additional checks are applied during reduction or
  // post parse analysis.
  op_one_assign: access_expr op_one_assign |
  binary_op_assign: access_expr binary_op_assign expression

statement ->
  implicit: statement_body NEWLINES |
  explicit: statement_body SEMICOLON

statements ->
  empty_list: |
  add: statements statement

optional_label_decl ->
  LABEL_DECL |
  unlabelled:

block_body -> LBRACE statements RBRACE
block_expr -> optional_label_decl block_body

// NOTE: label is applied to the entire if expression rather than individual
// branches.
if_expr ->
  no_else: IF sequence_expr block_body |
  if_else: IF sequence_expr block_body ELSE block_body |
  multi_if_else: IF sequence_expr block_body ELSE if_expr

// TODO
switch_expr -> SWITCH LBRACE CASE DEFAULT RBRACE

loop_expr ->
  infinite: FOR block_expr |
  while: FOR sequence_expr block_expr
  // TODO: FOR optional_assignment SEMICOLON sequence_expr SEMICOLON sequence_expr block_expr
  // TODO FOR let_decl IN sequence_expr block_expr

expression ->
  sequence_expr |
  if_expr: optional_label_decl if_expr |
  switch_expr: optional_label_decl switch_expr |
  loop_expr: optional_label_decl loop_expr

atom_type ->
  named: IDENTIFIER optional_generic_binding |
  explicit_struct_def |
  implicit_struct_def |
  explicit_enum_type |
  implicit_enum_type |
  trait_def |
  QUESTION

traitable_type ->
  atom_type |
  method_interface: BIT_NEG atom_type |  // atom type's public method
  trait: TILDE_TILDE atom_type  // atom type's public method and field

trait_mul_type ->
  traitable_type |
  intersect: trait_mul_type MUL traitable_type

trait_add_type ->
  trait_mul_type |
  union: trait_add_type ADD trait_mul_type |

  // This probably should be considered a mul type, but notation wise, it's
  // a add type.  Keeping this as an add type to keep precedence consistent
  // with expression.
  difference: trait_add_type SUB trait_mul_type

field_def_or_list ->
  pair: field_def OR field_def |
  add: field_def_or_list OR field_def

// XXX: Should unify the syntax with explicit enum ?
implicit_enum_type -> LPAREN field_def_or_list RPAREN

// TODO
explicit_enum_type -> ENUM LPAREN RPAREN

value_type ->
  trait_add_type |
  reference: BIT_AND trait_add_type |
  func_type

type_def ->
  definition: TYPE IDENTIFIER optional_generic_parameters value_type |
  constrained_def: TYPE IDENTIFIER optional_generic_parameters value_type IMPLEMENTS value_type |
  alias: TYPE IDENTIFIER EQUAL value_type

//
// Generic parameter definition
//

generic_parameter_def ->
  unconstrained: IDENTIFIER |
  constrained: IDENTIFIER value_type

generic_parameter_defs ->
  generic_parameter_def |
  add: generic_parameter_defs COMMA generic_parameter_def

optional_generic_parameter_defs ->
  generic_parameter_defs |
  nil:

optional_generic_parameters ->
  generic: DOLLAR_LBRACKET optional_generic_parameter_defs RBRACKET |
  nil:

//
// Explicit/Implicit struct definition
//

field_def ->
  explicit: IDENTIFIER value_type |
  implicit: value_type

field_defs ->
  field_def |
  implicit: field_defs NEWLINES field_def |
  explicit: field_defs COMMA field_def

optional_field_defs ->
  field_defs |
  nil:

implicit_struct_def -> LPAREN optional_field_defs RPAREN

explicit_struct_def -> STRUCT implicit_struct_def

//
// Trait definition
//

trait_property ->
  field_def |
  method_signature

trait_properties ->
  trait_property |
  implicit: trait_properties NEWLINES trait_property |
  explicit: trait_properties COMMA trait_property

optional_trait_properties ->
  trait_properties |
  nil:

trait_def -> TRAIT LPAREN optional_trait_properties RPAREN

//
// Function type, definition, trait method signature
// and anonymous func expression
//

return_type ->
  value_type |
  nil:

parameter_decl ->
  arg: IDENTIFIER value_type |
  vararg: IDENTIFIER DOTDOTDOT value_type |
  unamed: value_type |
  unnamed_vararg: DOTDOTDOT value_type

parameter_decls ->
  parameter_decl |
  add: parameter_decls COMMA parameter_decl

optional_parameter_decls ->
  parameter_decls |
  nil:

func_type -> FUNC LPAREN optional_parameter_decls RPAREN return_type

// NOTE: FUNC is needed to disambiguate method signature from field def.
// e.g., Foo (int, int) could mean a field named Foo with type
// struct(int, int), or a method called Foo that takes two argument if func
// is not present.
//
// XXX: allow generic parameters in method signature? No for now.
method_signature -> FUNC IDENTIFIER LPAREN optional_parameter_decls RPAREN return_type

parameter_def ->
  arg: IDENTIFIER value_type |
  vararg: IDENTIFIER DOTDOTDOT value_type

parameter_defs ->
  parameter_def |
  add: parameter_defs COMMA parameter_def

optional_parameter_defs ->
  parameter_defs |
  nil:

optional_receiver ->
  receiver: LPAREN parameter_def RPAREN |
  nil:

named_func_def ->
  FUNC optional_receiver IDENTIFIER optional_generic_parameters LPAREN optional_parameter_defs RPAREN return_type block_body

anonymous_func_expr ->
  FUNC LPAREN optional_parameter_defs RPAREN return_type block_body

//
// Package definition
//

package_def ->
  no_spec: PACKAGE IDENTIFIER |
  with_spec: PACKAGE IDENTIFIER LPAREN package_statements RPAREN

package_statement_body -> unsafe_statement

package_statement ->
  implicit: package_statement_body NEWLINES |
  explicit: package_statement_body SEMICOLON

package_statements ->
  empty_list: |
  add: package_statements package_statement

// Note: auxillary tokens that are consumed by the lexer internally
lex_internal_tokens ->
  SPACES |
  COMMENT

%%lang_specs{
go:
  package: parser
}%%
