%token SPACES // [ \t]+
%token NEWLINES // (\n|\r\n)+

%token COMMENT // //-style or block-style comment

%token INTEGER_LITERAL FLOAT_LITERAL RUNE_LITERAL STRING_LITERAL

%token IDENTIFIER
%token TRUE FALSE

%token IF ELSE SWITCH CASE DEFAULT FOR DO IN
%token RETURN BREAK CONTINUE

%token PACKAGE

%token UNSAFE

%token TYPE IMPLEMENTS STRUCT ENUM TRAIT
%token FUNC ASYNC DEFER
%token VAR

%token LABEL_DECL // <identifier>@
%token JUMP_LABEL // @<identifier>

%token LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET
%token DOT COMMA QUESTION SEMICOLON COLON EXCLAIM
%token DOLLAR_LBRACKET // $[
%token DOTDOTDOT // ...
%token TILDE_TILDE

%token ASSIGN

%token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN
%token ADD_ONE_ASSIGN SUB_ONE_ASSIGN
%token BIT_NEG_ASSIGN BIT_AND_ASSIGN BIT_OR_ASSIGN BIT_XOR_ASSIGN
%token BIT_LSHIFT_ASSIGN BIT_RSHIFT_ASSIGN

%token NOT AND OR
%token ADD SUB MUL DIV MOD
%token BIT_NEG BIT_AND BIT_XOR BIT_OR BIT_LSHIFT BIT_RSHIFT
%token EQUAL NOT_EQUAL LESS LESS_OR_EQUAL GREATER GREATER_OR_EQUAL

%token LEX_ERROR

%start source package_def type_def named_func_def expression lex_internal_tokens

source -> optional_definitions

optional_definitions ->
  NEWLINES |
  definitions: optional_newlines definitions optional_newlines |
  nil:

optional_newlines ->
  NEWLINES |
  nil:

definitions ->
  nil: definition |
  add: definitions NEWLINES definition

definition ->
  package_def |
  type_def |
  named_func_def |
  unsafe_statement

//
// Expressions ================================================================
//

var_pattern ->
  IDENTIFIER |
  tuple_pattern

tuple_pattern -> LPAREN field_var_patterns RPAREN

field_var_patterns ->
  field_var_pattern |
  add: field_var_patterns COMMA field_var_pattern

field_var_pattern ->
  positional: var_pattern |
  named: IDENTIFIER ASSIGN var_pattern |
  DOTDOTDOT

optional_value_type ->
  value_type |
  nil:

expression ->
  if_expr: optional_label_decl if_expr |
  switch_expr: optional_label_decl switch_expr |
  loop_expr: optional_label_decl loop_expr |
  sequence_expr |
  // NOTE: var_pattern is not a real expression.  Unexpected usage in real
  // expressions are rejected during type checking.
  var_pattern: VAR var_pattern optional_value_type

optional_label_decl ->
  LABEL_DECL |
  unlabelled:

//
// If control flow expression
//

// NOTE: label is applied to the entire if expression rather than individual
// branches.
if_expr ->
  no_else: IF sequence_expr block_body |
  if_else: IF sequence_expr block_body ELSE block_body |
  multi_if_else: IF sequence_expr block_body ELSE if_expr

//
// Switch control flow expression
//

// match patterns within the same case must all have identical variable binding

// Allow fallthrough iff the next case have identical (and fewer) variable
// bindings.
//
// e.g., OK.  y is binded to the same value
// switch val {
// case var (x, y): fallthrough
// case (_, var y): // do something
// }
//
// e.g., Not ok.  y != z
// switch val {
// case var (x, y): fallthrough
// case (_, var z): // do something
// }

// Switch need to be exhastive.
switch_expr -> SWITCH sequence_expr LBRACE case_branches optional_default_branch RBRACE

case_branches ->
  case_branch |
  add: case_branches case_branch

case_branch -> CASE patterns COLON sequence_expr

patterns ->
  pattern |
  multiple: patterns COMMA pattern

optional_default_branch ->
  default_branch |
  nil:

default_branch -> DEFAULT COLON sequence_expr

//
// For control flow expression
//

// NOTE: Since we use {} for expression grouping, we need the extra DO keyword
// to help the parser figure out which block is the loop's body.
//
// For example, suppose the infinite loop grammar is "FOR body_expr" and
// the while loop grammar is "FOR sequence_expr body_expr".  Then the while
// loop can be interpreted as an infinite loop "FOR sequence_expr", followed by
// an sequence statement "body_expr".
loop_expr ->
  infinite: DO block_body |
  do_while: DO block_body FOR sequence_expr |
  while: FOR sequence_expr DO block_body |
  iterator: FOR pattern IN sequence_expr DO block_body |
  for: FOR /* TODO var decl and/or basic statement */ SEMICOLON optional_sequence_expr SEMICOLON optional_sequence_expr DO block_body

optional_sequence_expr ->
  sequence_expr |
  nil:

//
// Block / sequence control flow expressions
//

sequence_expr -> or_expr

block_expr -> optional_label_decl block_body

block_body -> LBRACE statements RBRACE

statements ->
  empty_list: |
  add: statements statement

statement ->
  implicit: statement_body NEWLINES |
  explicit: statement_body SEMICOLON

statement_body ->
  unsafe_statement |

  expression_or_implicit_struct: expressions |

  // maybe allow pseudo-call such as struct initialization?
  //
  // NOTE: call_expr's access_expr and its arguments are evaluated immediately
  // Only the call itself is async.
  async: ASYNC call_expr |  // returns an await handler

  // Returns unit
  //
  // XXX: maybe make defer's call_expr run on the nearest scope exit rather
  // than on function scope exit.  Transpiling this semantic to golang would
  // be annoying since golang's defer operate on function rather than scope
  // exit.  Maybe just code gen the defer call on every exit point instead of
  // relying on golang's defer?
  //
  // Need to ensure this an actual function call, not a struct initialization.
  //
  // NOTE: call_expr's access_expr and its arguments are evaluated immediately.
  // Only the call itself is deferred.
  defer: DEFER call_expr |

  // - compiler should optimize away the await handler if it's not used.

  jump_statement |

  // XXX: var fixed x = 5
  // x is not reassignable after initial assignment.
  // if x behaves like a constant if the object reference is immutable, and no
  // field are publically accessible.

  assign_statement: pattern ASSIGN expression |

  // NOTE: assignment can only operate on proper address values.  Additional
  // checks are applied during post analysis.
  unary_op_assign_statement: access_expr unary_op_assign |
  binary_op_assign_statement: access_expr binary_op_assign expression

//
// Assign statements
//

pattern ->
  // NOTE: expression captures identifier and tuple vars, as well as fully
  // evaluated expressions.  Additional post analysis checks are needed to
  // reject invalid usage, depending on the context (e.g., assignment should
  // only allow identifier expressions)
  expression |

  // Note: parsing VAR <pkg>.<enum type>.<enum value>(...) is painful, hence
  // we won't support this form. (the expression actually parses explicit enum
  // match pattern, where VARs are inside the data list, but we should reject
  // this form since we reject the other form)
  enum_match_pattern: DOT IDENTIFIER implicit_struct_expr |
  enum_var_pattern: VAR DOT IDENTIFIER tuple_pattern

unary_op_assign ->
  ADD_ONE_ASSIGN |
  SUB_ONE_ASSIGN

binary_op_assign ->
  ADD_ASSIGN |
  SUB_ASSIGN |
  MUL_ASSIGN |
  DIV_ASSIGN |
  MOD_ASSIGN |
  BIT_NEG_ASSIGN |
  BIT_AND_ASSIGN |
  BIT_OR_ASSIGN |
  BIT_XOR_ASSIGN |
  BIT_LSHIFT_ASSIGN |
  BIT_RSHIFT_ASSIGN

//
// Unsafe statement
//

// escape hatch to get a basic compiler/transpiler running.
// unsafe<go> "emit verbatim go source"
unsafe_statement -> UNSAFE LESS IDENTIFIER GREATER STRING_LITERAL

//
// Jump statement
//

jump_statement ->
  jump_type optional_jump_label optional_expressions

jump_type ->
  RETURN |
  BREAK |
  CONTINUE

optional_jump_label ->
  JUMP_LABEL |
  unlabelled:

expressions ->
  expression |
  add: expressions COMMA expression

optional_expressions ->
  expressions |
  nil:

//
// Call expression
//

call_expr -> access_expr optional_generic_binding LPAREN optional_arguments RPAREN

optional_generic_binding ->
  binding: DOLLAR_LBRACKET optional_generic_arguments RBRACKET |
  nil:

optional_generic_arguments ->
  generic_arguments |
  nil:

// XXX allow named generic argument?
generic_arguments ->
  value_type |
  add: generic_arguments COMMA value_type

optional_arguments ->
  arguments |
  nil:

arguments ->
  argument |
  add: arguments COMMA argument

argument ->
  positional: expression |
  named: IDENTIFIER ASSIGN expression |
  colon_expressions |
  // NOTE: ... is not a real expression.  Unexpected usage in real expressions
  // are rejected during type checking.
  DOTDOTDOT

colon_expressions ->
  pair: optional_expression COLON optional_expression |
  add: colon_expressions COLON optional_expression

optional_expression ->
  expression |
  nil:

//
// Simple expressions (in decreasing order precedence)
//

// TODO cast
// TODO type isa check
// TODO is check
atom_expr ->
  literal |
  IDENTIFIER |
  block_expr |
  anonymous_func_expr |
  initialize_expr: initializable_type LPAREN arguments RPAREN |
  implicit_struct_expr |
  LEX_ERROR

literal ->
  TRUE |
  FALSE |
  INTEGER_LITERAL |
  FLOAT_LITERAL |
  RUNE_LITERAL |
  STRING_LITERAL

implicit_struct_expr -> LPAREN arguments RPAREN

access_expr ->
  atom_expr |
  access: access_expr DOT IDENTIFIER |
  call_expr |
  index: access_expr LBRACKET argument RBRACKET

postfix_unary_expr ->
  access_expr |
  question: access_expr QUESTION

prefix_unary_op ->
  NOT |
  BIT_NEG |
  SUB |
  // "deref" copies an lvalue object.  The reference can be either mutable or
  // immutable.
  MUL |
  // "ref" returns a mutable reference to the lvalue object.  ref-ing can be
  // applied on either mutable or immutable referenced location.
  BIT_AND

prefix_unary_expr ->
  postfix_unary_expr |
  prefix_op: prefix_unary_op prefix_unary_expr

mul_op ->
  MUL |
  DIV |
  MOD |
  BIT_AND |
  BIT_LSHIFT |
  BIT_RSHIFT

mul_expr ->
  prefix_unary_expr |
  op: mul_expr mul_op prefix_unary_expr

add_op ->
  ADD |
  SUB |
  BIT_OR |
  BIT_XOR

add_expr ->
  mul_expr |
  op: add_expr add_op mul_expr

cmp_op ->
  EQUAL |
  NOT_EQUAL |
  LESS |
  LESS_OR_EQUAL |
  GREATER |
  GREATER_OR_EQUAL

cmp_expr ->
  add_expr |
  op: cmp_expr cmp_op add_expr

and_expr ->
  cmp_expr |
  op: and_expr AND cmp_expr

or_expr ->
  and_expr |
  op: or_expr OR and_expr

//
// Types ======================================================================
//

// Note: named type initializations are parsed as call_expr instead of
// initialize_expr
initializable_type ->
  explicit_struct_def |
  slice: LBRACKET value_type RBRACKET |  // shorthand for Slice$[ <value_type> ]
  array: LBRACKET value_type COMMA INTEGER_LITERAL RBRACKET |
  map: LBRACKET value_type COLON value_type RBRACKET // shorthand for Map$[ <value_type> , <value_type> ]

atom_type ->
  initializable_type |
  named: IDENTIFIER optional_generic_binding |
  extern_named: IDENTIFIER DOT IDENTIFIER optional_generic_binding |
  inferred: DOT optional_generic_binding |  // XXX: maybe use a different token symbol
  implicit_struct_def |
  explicit_enum_def |
  implicit_enum_def |
  trait_def |
  func_type |
  LEX_ERROR

// NOTE: allowing return type to use trait algebra without explicitly wrapping
// inside a trait() would cause to ambiguity.  e.g.,
// "func() A + B" could mean func() returning "A + B" or "func() A" + "B"
returnable_type ->
  atom_type |
  optional: QUESTION returnable_type | // shorthand for Optional$[ <atom_type> ]
  result: EXCLAIM returnable_type | // shorthand for Result$[ <atom_type> ]
  reference: BIT_AND returnable_type |
  public_methods_trait: BIT_NEG returnable_type |  // type's public methods
  public_trait: TILDE_TILDE returnable_type  // type's public methods and fields

// NOTE: use explicit trait() to specify op precedence e.g.,
// trait( trait(A+B) * C)
value_type ->
  returnable_type |
  trait_intersect: value_type MUL returnable_type |
  trait_union: value_type ADD returnable_type |
  trait_difference: value_type SUB returnable_type

type_def ->
  definition: TYPE IDENTIFIER optional_generic_parameters value_type |
  constrained_def: TYPE IDENTIFIER optional_generic_parameters value_type IMPLEMENTS value_type |
  alias: TYPE IDENTIFIER EQUAL value_type

//
// Generic parameter definition
//

// XXX: allow default generic parameter value?
generic_parameter_def ->
  unconstrained: IDENTIFIER |
  constrained: IDENTIFIER value_type

generic_parameter_defs ->
  generic_parameter_def |
  add: generic_parameter_defs COMMA generic_parameter_def

optional_generic_parameter_defs ->
  generic_parameter_defs |
  nil:

optional_generic_parameters ->
  generic: DOLLAR_LBRACKET optional_generic_parameter_defs RBRACKET |
  nil:

//
// Explicit/Implicit struct definition
//

field_def ->
  explicit: IDENTIFIER value_type |
  implicit: value_type |
  unsafe_statement

implicit_field_defs ->
  field_def |
  add: implicit_field_defs COMMA field_def

optional_implicit_field_defs ->
  implicit_field_defs |
  nil:

implicit_struct_def -> LPAREN optional_implicit_field_defs RPAREN

explicit_field_defs ->
  field_def |
  implicit: explicit_field_defs NEWLINES field_def |
  explicit: explicit_field_defs COMMA field_def

optional_explicit_field_defs ->
  explicit_field_defs |
  nil:

explicit_struct_def -> STRUCT LPAREN optional_explicit_field_defs RPAREN

//
// Explicit/Implicit enum definition
//

// NOTE: for now, enum value must have a data type.
// XXX: maybe allow "_" for no data?

enum_value_def ->
  field_def |
  default: field_def ASSIGN DEFAULT

// NOTE: <value_type> OR () should be treated as Optional$[<value_type>]
implicit_enum_value_defs ->
  pair: enum_value_def OR enum_value_def |
  add: implicit_enum_value_defs OR enum_value_def

implicit_enum_def -> LPAREN implicit_enum_value_defs RPAREN

explicit_enum_value_defs ->
  explicit_pair: enum_value_def OR enum_value_def |
  implicit_pair: enum_value_def NEWLINES enum_value_def |
  explicit_add: implicit_enum_value_defs OR enum_value_def |
  implicit_add: implicit_enum_value_defs NEWLINES enum_value_def

explicit_enum_def -> ENUM LPAREN explicit_enum_value_defs RPAREN

//
// Trait definition
//

trait_property ->
  field_def |
  method_signature

trait_properties ->
  trait_property |
  implicit: trait_properties NEWLINES trait_property |
  explicit: trait_properties COMMA trait_property

optional_trait_properties ->
  trait_properties |
  nil:

trait_def -> TRAIT LPAREN optional_trait_properties RPAREN

//
// Function type, definition, trait method signature
// and anonymous func expression
//

return_type ->
  returnable_type |
  nil:

parameter_decl ->
  arg: IDENTIFIER value_type |
  vararg: IDENTIFIER DOTDOTDOT value_type |
  unamed: value_type |
  unnamed_vararg: DOTDOTDOT value_type

parameter_decls ->
  parameter_decl |
  add: parameter_decls COMMA parameter_decl

optional_parameter_decls ->
  parameter_decls |
  nil:

func_type -> FUNC LPAREN optional_parameter_decls RPAREN return_type

// NOTE: FUNC is needed to disambiguate method signature from field def.
// e.g., Foo (int, int) could mean a field named Foo with type
// struct(int, int), or a method called Foo that takes two argument if func
// is not present.
//
// XXX: allow generic parameters in method signature? No, for go transpiler.
// Ideally yes.  We should allow function overloading as long as the functions
// all conforms to the same (unconstrainted) generic parameterized signature.
// Ambiguous usage would need to explicitly specify the generic parameter.
method_signature -> FUNC IDENTIFIER LPAREN optional_parameter_decls RPAREN return_type

parameter_def ->
  arg: IDENTIFIER value_type |
  vararg: IDENTIFIER DOTDOTDOT value_type

parameter_defs ->
  parameter_def |
  add: parameter_defs COMMA parameter_def

optional_parameter_defs ->
  parameter_defs |
  nil:

optional_receiver ->
  receiver: LPAREN parameter_def RPAREN |
  nil:

named_func_def ->
  FUNC optional_receiver IDENTIFIER optional_generic_parameters LPAREN optional_parameter_defs RPAREN return_type block_body

anonymous_func_expr ->
  FUNC LPAREN optional_parameter_defs RPAREN return_type block_body

//
// Package definition =========================================================
//

package_def ->
  no_spec: PACKAGE IDENTIFIER |
  with_spec: PACKAGE IDENTIFIER LPAREN package_statements RPAREN

package_statement_body -> unsafe_statement

package_statement ->
  implicit: package_statement_body NEWLINES |
  explicit: package_statement_body SEMICOLON

package_statements ->
  empty_list: |
  add: package_statements package_statement

// Note: auxillary tokens that are consumed by the lexer internally
lex_internal_tokens ->
  SPACES |
  COMMENT

%%lang_specs{
go:
  package: parser
}%%
