%token<Count> NEWLINES // (\n|\r\n)+

%token<Value> COMMENT_GROUPS

%token<Value> INTEGER_LITERAL FLOAT_LITERAL RUNE_LITERAL STRING_LITERAL

// _ is never a real identifier, and is only used as a variable or type
// placeholder.  Identifiers with prefix "_" are private to the package.
// nameing convention is lower camelcase for variables, upper camelcase for
// types.
%token<Value> IDENTIFIER

%token<Value> TRUE FALSE

%token<Value> IF ELSE SWITCH CASE DEFAULT FOR DO IN
%token<Value> RETURN BREAK CONTINUE FALLTHROUGH

%token<Value> PACKAGE IMPORT AS

%token<Value> UNSAFE

%token<Value> TYPE IMPLEMENTS STRUCT ENUM TRAIT
%token<Value> FUNC ASYNC DEFER
%token<Value> VAR LET

%token<Value> NOT AND OR

%token<Value> LABEL_DECL // <identifier>@
%token<Value> JUMP_LABEL // @<identifier>

%token<Value> LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET
%token<Value> DOT COMMA QUESTION SEMICOLON COLON EXCLAIM
%token<Value> DOLLAR_LBRACKET // $[
%token<Value> ELLIPSIS // ...
%token<Value> TILDE_TILDE

%token<Value> ASSIGN

%token<Value> ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN
%token<Value> ADD_ONE_ASSIGN SUB_ONE_ASSIGN
%token<Value> BIT_NEG_ASSIGN BIT_AND_ASSIGN BIT_OR_ASSIGN BIT_XOR_ASSIGN
%token<Value> BIT_LSHIFT_ASSIGN BIT_RSHIFT_ASSIGN

%token<Value> ADD SUB MUL DIV MOD
%token<Value> BIT_NEG BIT_AND BIT_XOR BIT_OR BIT_LSHIFT BIT_RSHIFT
%token<Value> EQUAL NOT_EQUAL LESS LESS_OR_EQUAL GREATER GREATER_OR_EQUAL

%token<ParseError> PARSE_ERROR

%start source package_def type_def named_func_def expression

source<SourceDefinitions> -> optional_definitions

optional_definitions ->
  NEWLINES |
  definitions: optional_newlines definitions optional_newlines |
  nil:

optional_newlines ->
  NEWLINES |
  nil:

definitions<SourceDefinitions> ->
  definition |
  add: definitions NEWLINES definition

definition<SourceDefinition> ->
  // There can only be one package_def per package
  package_def |
  type_def |
  named_func_def |
  global_var_def: var_decl_pattern |
  global_var_assignment: var_decl_pattern ASSIGN expression |
  // There can only be at most one statement_block per package, which act as
  // the package's init function
  statement_block |
  // Free floating comment groups that are not part of any other symbol.
  // This can happen if the source file only has comments, or if there are
  // comments at the end of the source.
  COMMENT_GROUPS

//
// Statement block
//

// IMPORTANT NOTE!!!
//
// The grammar is specified in such a way that only the statement_block rule
// uses LBRACE and RBRACE.  Hence, we can unconditionally parse a
// statement_block when we encounters a LBRACE.
//
// This enables the parser to parse the source in piecemeal manner, which
// enables the parser to collect more parse errors on a single run.
//
// Post analysis is needed to ensure statements are valid for the specific
// context.
//
// Note: statement_block's value type can be either the statement_block's
// real value type, or PARSE_ERROR's value type
statement_block -> LBRACE statements RBRACE

statements<Statements> ->
  empty_list: |
  add: statements statement

statement<Statement> ->
  implicit: statement_body NEWLINES |
  explicit: statement_body SEMICOLON

simple_statement_body<Statement> ->
  = unsafe_statement |

  = expression_or_improper_struct_statement |

  // NOTE: Only applicable in expression blocks
  = callback_op_statement |

  // NOTE: Only applicable in expression blocks
  = jump_statement |

  // NOTE: variable declaration without assignment is parsed as an expression.
  //
  // NOTE: package level assign pattern must be a var/let declaration
  = assign_statement |

  // NOTE: assignment can only operate on proper address values.  Additional
  // checks are applied during post analysis.
  //
  // NOTE: Only applicable in expression block
  = unary_op_assign_statement |
  = binary_op_assign_statement |

  // Only applicable to switch case block (must be the last statement in the
  // case branch)
  = fallthrough_statement

statement_body<Statement> ->
  = simple_statement_body |

  // NOTE: Only applicable to package_def
  = import_statement |

  // NOTE: Only applicable to switch case block.
  // Post analysis is needed to associate statements to cases (move trailing
  // non-case statements into case's data structure).
  case_branch_statement: CASE case_patterns COLON optional_simple_statement_body |
  default_branch_statement: DEFAULT COLON optional_simple_statement_body

optional_simple_statement_body<Statement> ->
  = simple_statement_body |
  nil:

//
//
//

expression_or_improper_struct_statement<Statement> -> expressions

//
// Async / defer statements
//

callback_op<Value> ->
  = ASYNC |
  = DEFER

// async returns an await handler, whereas defer returns unit.
//
// XXX: maybe make defer's call_expr run on the nearest scope exit rather
// than on function scope exit.  Transpiling this semantic to golang would
// be annoying since golang's defer operate on function rather than scope
// exit.  Maybe just code gen the defer call on every exit point instead of
// relying on golang's defer?
//
// Need to ensure this an actual function call, not a struct initialization.
// XXX: maybe allow async to use pseudo-call such as struct initialization?
//
// NOTE: compiler should optimize away the async await handler if it's not
// used.
//
// NOTE: call_expr's accessible_expr and its arguments are evaluated immediately
// Only the call itself is applicable to the callback_op.
callback_op_statement<Statement> -> callback_op call_expr

//
// Assign statements
//

unary_op_assign<Value> ->
  = ADD_ONE_ASSIGN |
  = SUB_ONE_ASSIGN

binary_op_assign<Value> ->
  = ADD_ASSIGN |
  = SUB_ASSIGN |
  = MUL_ASSIGN |
  = DIV_ASSIGN |
  = MOD_ASSIGN |
  = BIT_NEG_ASSIGN |
  = BIT_AND_ASSIGN |
  = BIT_OR_ASSIGN |
  = BIT_XOR_ASSIGN |
  = BIT_LSHIFT_ASSIGN |
  = BIT_RSHIFT_ASSIGN

//
// Unsafe statement
//

// escape hatch to get a basic compiler/transpiler running.
// unsafe<go> "emit verbatim go source"
unsafe_statement<Statement> -> UNSAFE LESS IDENTIFIER GREATER STRING_LITERAL

//
// Jump / fallthrough statements
//

jump_statement<Statement> ->
  unlabeled_no_value: jump_type |
  unlabeled_valued: jump_type expressions |
  labeled_no_value: jump_type JUMP_LABEL |
  labeled_valued: jump_type JUMP_LABEL expressions

jump_type<Value> ->
  = RETURN |
  = BREAK |
  = CONTINUE

expressions ->
  expression |
  add: expressions COMMA expression

fallthrough_statement<Statement> -> FALLTHROUGH

//
// Assignment statements
//

assign_statement<Statement> -> assign_pattern ASSIGN expression

unary_op_assign_statement<Statement> -> accessible_expr unary_op_assign

binary_op_assign_statement<Statement> -> accessible_expr binary_op_assign expression

//
// Import statement
//

import_statement<Statement> ->
  single: IMPORT import_clause |
  multiple: IMPORT LPAREN import_clauses RPAREN

import_clause ->
  STRING_LITERAL |
  alias: STRING_LITERAL AS IDENTIFIER

import_clause_terminal ->
  implicit: import_clause NEWLINES |
  explicit: import_clause COMMA

import_clauses ->
  first: import_clause_terminal |
  add: import_clauses import_clause_terminal

//
// Case statement
//

case_patterns ->
  case_pattern |
  multiple: case_patterns COMMA case_pattern

//
// Variable declaration pattern (Pseudo expression) ===========================
//

// VAR declares a reassignable variable. LET declares a non-reassignable
// variable.  A "constant" is a LET variable associated with a type with no
// public access to fields, and no mutation methods.
var_decl_pattern -> var_or_let var_pattern optional_value_type

var_or_let<Value> ->
  = VAR |
  = LET

var_pattern ->
  IDENTIFIER |
  tuple_pattern

tuple_pattern -> LPAREN field_var_patterns RPAREN

field_var_patterns ->
  field_var_pattern |
  add: field_var_patterns COMMA field_var_pattern

field_var_pattern ->
  positional: var_pattern |
  named: IDENTIFIER ASSIGN var_pattern |
  ELLIPSIS

optional_value_type<TypeExpression> ->
  = value_type |
  nil:

// NOTE: expression captures identifier and tuple vars, as well as fully
// evaluated expressions.  Additional post analysis checks are needed to
// reject invalid usage, depending on the context (e.g., assignment should
// only allow identifier expressions)
assign_pattern ->
  sequence_expr

case_pattern ->
  = assign_pattern |

  // Note: parsing VAR <pkg>.<enum type>.<enum value>(...) is painful using
  // context free grammar (e.g, need to make VAR a prefix op expression instead
  // of var_decl_pattern), hence we won't support this form. (the expression
  // actually parses explicit enum match pattern, where VARs are inside the
  // data list, but we should reject this form for consistency)
  enum_match_pattern: DOT IDENTIFIER implicit_struct_expr |
  enum_var_decl_pattern: VAR DOT IDENTIFIER tuple_pattern

//
// Expressions ================================================================
//

expression<Expression> ->
  if_expr: optional_label_decl if_expr |
  switch_expr: optional_label_decl switch_expr |
  loop_expr: optional_label_decl loop_expr |
  = sequence_expr

optional_label_decl<Value> ->
  LABEL_DECL |
  unlabelled:

//
// Sequence control flow expression
//

sequence_expr<Expression> ->
  = or_expr |
  // NOTE: var_decl_pattern is not a real expression.  Unexpected usage in real
  // expressions are rejected during type checking.
  var_decl_pattern |
  // Case pattern need to disambiguate between using a variable for pattern
  // matching vs assigning a value to the variable (This is optional in
  // assign_pattern since it's unambiguous)
  assign_var_pattern: GREATER sequence_expr

//
// If control flow expression
//

// NOTE: label is applied to the entire if expression rather than individual
// branches.
if_expr<Expression> ->
  no_else: IF condition statement_block |
  if_else: IF condition statement_block ELSE statement_block |
  multi_if_else: IF condition statement_block ELSE if_expr

condition ->
  sequence_expr |
  case: CASE case_patterns ASSIGN sequence_expr

//
// Switch control flow expression
//

// match patterns within the same case must all have identical variable binding

// Allow fallthrough iff the next case have identical (and fewer) variable
// bindings.
//
// e.g., OK.  y is binded to the same value
// switch val {
// case var (x, y): fallthrough
// case (_, var y): // do something
// }
//
// e.g., Not ok.  y != z
// switch val {
// case var (x, y): fallthrough
// case (_, var z): // do something
// }

// Switch need to be exhastive.
switch_expr<Expression> -> SWITCH sequence_expr statement_block

//
// For control flow expression
//

// NOTE: Since we use {} for expression grouping, we need the extra DO keyword
// to help the parser figure out which block is the loop's body.
//
// For example, suppose the infinite loop grammar is "FOR body_expr" and
// the while loop grammar is "FOR sequence_expr body_expr".  Then the while
// loop can be interpreted as an infinite loop "FOR sequence_expr", followed by
// an sequence statement "body_expr".
loop_expr<Expression> ->
  infinite: DO statement_block |
  do_while: DO statement_block FOR sequence_expr |
  while: FOR sequence_expr DO statement_block |
  iterator: FOR assign_pattern IN sequence_expr DO statement_block |
  for: FOR for_assignment SEMICOLON optional_sequence_expr SEMICOLON optional_sequence_expr DO statement_block

optional_sequence_expr<Expression> ->
  sequence_expr |
  nil:

for_assignment ->
  sequence_expr |
  assign: assign_pattern ASSIGN sequence_expr

//
// Call expression
//

call_expr<Expression> ->
  accessible_expr optional_generic_binding LPAREN optional_arguments RPAREN

optional_generic_binding ->
  binding: DOLLAR_LBRACKET optional_generic_arguments RBRACKET |
  nil:

optional_generic_arguments ->
  = generic_arguments |
  nil:

comma_generic_arguments ->
  add: comma_generic_arguments COMMA value_type |
  nil:

// XXX allow named generic argument?
generic_arguments ->
  proper: value_type comma_generic_arguments |
  improper: value_type comma_generic_arguments COMMA

optional_arguments<ArgumentList> ->
  = arguments |
  nil:

comma_arguments<ArgumentList> ->
  add: comma_arguments COMMA argument |
  nil:

arguments<ArgumentList> ->
  proper: argument comma_arguments |
  improper: argument comma_arguments COMMA

argument<Argument> ->
  positional: expression |
  colon_expr |
  named_assignment: IDENTIFIER ASSIGN expression |
  // XXX: Under golang-style vararg assignment, the signature f(args ...int)
  // will not accept f(0, 1, x...) where x an int slice.  Maybe relax this into
  // vararg expansion instead?
  vararg_assignment: expression ELLIPSIS |
  // NOTE: ... is not a real expression, and is only used for pattern matching.
  // Unexpected usage in real expressions are rejected during type checking.
  skip_pattern: ELLIPSIS

// An (n >= 2)-tuple expression usable only as an argument
colon_expr<Expression> ->
  unit_unit_pair: COLON |
  expr_unit_pair: expression COLON |
  unit_expr_pair: COLON expression |
  expr_expr_pair: expression COLON expression |
  colon_expr_unit_tuple: colon_expr COLON |
  colon_expr_expr_tuple: colon_expr COLON expression

//
// Simple expressions (in decreasing order precedence)
//

// TODO cast
// TODO type isa check
// TODO is check
// TODO select (via trait instead of channel)
atom_expr<Expression> ->
  = parse_error_expr |
  = literal_expr |
  = identifier_expr |
  = block_expr |
  = anonymous_func_expr |
  = initialize_expr |
  = implicit_struct_expr

parse_error_expr<Expression> -> PARSE_ERROR

literal_expr<Expression> ->
  TRUE |
  FALSE |
  INTEGER_LITERAL |
  FLOAT_LITERAL |
  RUNE_LITERAL |
  STRING_LITERAL

identifier_expr<Expression> ->  IDENTIFIER

block_expr<Expression> ->  optional_label_decl statement_block

initialize_expr<Expression> ->
  initializable_type LPAREN optional_arguments RPAREN

implicit_struct_expr<Expression> -> LPAREN optional_arguments RPAREN

accessible_expr<Expression> ->
  = atom_expr |
  = access_expr |
  = call_expr |
  = index_expr

access_expr<Expression> -> accessible_expr DOT IDENTIFIER

// Note: post analysis need to check to ensure argument either a positional
// or colon expressions argument.
index_expr<Expression> -> accessible_expr LBRACKET argument RBRACKET

postfixable_expr<Expression> ->
  = accessible_expr |
  = postfix_unary_expr

postfix_unary_expr<Expression> ->  accessible_expr QUESTION

prefixable_expr<Expression> ->
  = postfixable_expr |
  = prefix_unary_expr

prefix_unary_expr<Expression> -> prefix_unary_op prefixable_expr

prefix_unary_op<Value> ->
  = NOT |
  = BIT_NEG |
  = SUB |
  // "deref" copies an lvalue object.  The reference can be either mutable or
  // immutable.
  = MUL |
  // "ref" returns a mutable reference to the lvalue object.  ref-ing can be
  // applied on either mutable or immutable referenced location.
  = BIT_AND

mul_expr<Expression> ->
  = prefixable_expr |
  = binary_mul_expr

binary_mul_expr<Expression> -> mul_expr mul_op prefixable_expr

mul_op<Value> ->
  = MUL |
  = DIV |
  = MOD |
  = BIT_AND |
  = BIT_LSHIFT |
  = BIT_RSHIFT

add_expr<Expression> ->
  = mul_expr |
  = binary_add_expr

binary_add_expr<Expression> -> add_expr add_op mul_expr

add_op<Value> ->
  = ADD |
  = SUB |
  = BIT_OR |
  = BIT_XOR

cmp_expr<Expression> ->
  = add_expr |
  = binary_cmp_expr

binary_cmp_expr<Expression> -> cmp_expr cmp_op add_expr

cmp_op<Value> ->
  = EQUAL |
  = NOT_EQUAL |
  = LESS |
  = LESS_OR_EQUAL |
  = GREATER |
  = GREATER_OR_EQUAL

and_expr<Expression> ->
  = cmp_expr |
  = binary_and_expr

binary_and_expr<Expression> -> and_expr AND cmp_expr

or_expr<Expression> ->
  = and_expr |
  = binary_or_expr

binary_or_expr<Expression> -> or_expr OR and_expr

//
// Types ======================================================================
//

// Note: named type initializations are parsed as call_expr instead of
// initialize_expr
initializable_type<TypeExpression> ->
  = explicit_struct_def |
  slice: LBRACKET value_type RBRACKET |  // shorthand for Slice$[ <value_type> ]
  array: LBRACKET value_type COMMA INTEGER_LITERAL RBRACKET |
  map: LBRACKET value_type COLON value_type RBRACKET // shorthand for Map$[ <value_type> , <value_type> ]

atom_type<TypeExpression> ->
  = initializable_type |
  named: IDENTIFIER optional_generic_binding |
  extern_named: IDENTIFIER DOT IDENTIFIER optional_generic_binding |
  inferred: DOT optional_generic_binding |  // XXX: maybe use a different token symbol
  = implicit_struct_def |
  = explicit_enum_def |
  = implicit_enum_def |
  = trait_def |
  = func_type |
  = parse_error_type

parse_error_type<TypeExpression> -> PARSE_ERROR

// NOTE: allowing return type to use trait algebra without explicitly wrapping
// inside a trait() would cause to ambiguity.  e.g.,
// "func() A + B" could mean func() returning "A + B" or "func() A" + "B"
returnable_type<TypeExpression> ->
  = atom_type |
  = prefixed_type

prefixed_type<TypeExpression> -> prefix_type_op returnable_type

prefix_type_op<Value> ->
  = QUESTION | // shorthand for Optional$[ <atom_type> ]
  = EXCLAIM | // shorthand for Result$[ <atom_type> ]
  = BIT_AND | // reference type
  = BIT_NEG | // type's public method signatures trait
  = TILDE_TILDE // type's public method signatures and fields trait

// NOTE: use explicit trait() to specify op precedence e.g.,
// trait( trait(A+B) * C)
value_type<TypeExpression> ->
  = returnable_type |
  = trait_op_type

trait_op_type<TypeExpression> -> value_type trait_op returnable_type

trait_op<Value> ->
  = MUL | // trait intersect
  = ADD | // trait union
  = SUB // trait difference

type_def<SourceDefinition> ->
  definition: TYPE IDENTIFIER optional_generic_parameters value_type |
  constrained_def: TYPE IDENTIFIER optional_generic_parameters value_type IMPLEMENTS value_type |
  alias: TYPE IDENTIFIER ASSIGN value_type

//
// Generic parameter definition
//

// XXX: allow default generic parameter value?
generic_parameter_def ->
  unconstrained: IDENTIFIER |
  constrained: IDENTIFIER value_type

comma_generic_parameter_defs ->
  add: comma_generic_parameter_defs COMMA generic_parameter_def |
  nil:

generic_parameter_defs ->
  proper: generic_parameter_def comma_generic_parameter_defs |
  improper: generic_parameter_def comma_generic_parameter_defs COMMA

optional_generic_parameter_defs ->
  generic_parameter_defs |
  nil:

optional_generic_parameters ->
  generic: DOLLAR_LBRACKET optional_generic_parameter_defs RBRACKET |
  nil:

//
// Explicit/Implicit struct definition
//

field_def ->
  explicit: IDENTIFIER value_type |
  implicit: value_type |
  unsafe_statement

comma_implicit_field_defs ->
  add: comma_implicit_field_defs COMMA field_def |
  nil:

implicit_field_defs ->
  proper: field_def comma_implicit_field_defs |
  improper: field_def comma_implicit_field_defs COMMA

optional_implicit_field_defs ->
  implicit_field_defs |
  nil:

implicit_struct_def<TypeExpression> ->
  LPAREN optional_implicit_field_defs RPAREN

terminal_explicit_field_defs ->
  add_implicit: terminal_explicit_field_defs NEWLINES field_def |
  add_explicit: terminal_explicit_field_defs COMMA field_def |
  nil:

explicit_field_defs ->
  proper: field_def terminal_explicit_field_defs |
  improper_implicit: field_def terminal_explicit_field_defs NEWLINES |
  improper_explicit: field_def terminal_explicit_field_defs COMMA

optional_explicit_field_defs ->
  explicit_field_defs |
  nil:

explicit_struct_def<TypeExpression> ->
  STRUCT LPAREN optional_explicit_field_defs RPAREN

//
// Explicit/Implicit enum definition
//

// NOTE: use "_" for field type denote no data associated with the  enum value.
enum_value_def ->
  field_def |
  default: field_def ASSIGN DEFAULT

// NOTE: inferred "<value_type> OR ()" should be treated as
// Optional$[<value_type>]
//
// NOTE: inferred "<value_type> OR Error" should be treated as
// Result$[<value_type>]
//
// NOTE: both inferred types "<value_type> OR Error or ()" and
// "<value_type> OR () OR Error" should be treated as
// Result$[ Optional$[ <value_type> ] ]
implicit_enum_value_defs ->
  pair: enum_value_def OR enum_value_def |
  add: implicit_enum_value_defs OR enum_value_def

implicit_enum_def<TypeExpression> -> LPAREN implicit_enum_value_defs RPAREN

explicit_enum_value_defs ->
  explicit_pair: enum_value_def OR enum_value_def |
  implicit_pair: enum_value_def NEWLINES enum_value_def |
  explicit_add: implicit_enum_value_defs OR enum_value_def |
  implicit_add: implicit_enum_value_defs NEWLINES enum_value_def

explicit_enum_def<TypeExpression> -> ENUM LPAREN explicit_enum_value_defs RPAREN

//
// Trait definition
//

trait_property ->
  field_def |
  method_signature

terminal_trait_properties ->
  add_implicit: terminal_trait_properties NEWLINES trait_property |
  add_explicit: terminal_trait_properties COMMA trait_property |
  nil:

trait_properties ->
  proper: trait_property terminal_trait_properties |
  improper_implicit: trait_property terminal_trait_properties NEWLINES |
  improper_explicit: trait_property terminal_trait_properties COMMA

optional_trait_properties ->
  trait_properties |
  nil:

trait_def<TypeExpression> -> TRAIT LPAREN optional_trait_properties RPAREN

//
// Function type, definition, trait method signature
// and anonymous func expression
//

return_type<TypeExpression> ->
  returnable_type |
  nil:

parameter_decl ->
  arg: IDENTIFIER value_type |
  vararg: IDENTIFIER ELLIPSIS value_type |
  unamed: value_type |
  unnamed_vararg: ELLIPSIS value_type

comma_parameter_decls ->
  add: comma_parameter_decls COMMA parameter_decl |
  nil:

parameter_decls ->
  proper: parameter_decl comma_parameter_decls |
  improper: parameter_decl comma_parameter_decls COMMA

optional_parameter_decls ->
  parameter_decls |
  nil:

func_type<TypeExpression> ->
  FUNC LPAREN optional_parameter_decls RPAREN return_type

// NOTE: FUNC is needed to disambiguate method signature from field def.
// e.g., Foo (int, int) could mean a field named Foo with type
// struct(int, int), or a method called Foo that takes two argument if func
// is not present.
//
// XXX: allow generic parameters in method signature? No, for go transpiler.
// Ideally yes.  We should allow function overloading as long as the functions
// all conforms to the same (unconstrainted) generic parameterized signature.
// Ambiguous usage would need to explicitly specify the generic parameter.
method_signature -> FUNC IDENTIFIER LPAREN optional_parameter_decls RPAREN return_type

// NOTE: Parameter that don't specify any value will be inferred as a mutable
// reference by default, i.e., equivalent to "&.".  Parameter that specify "."
// as its type will be inferred as copy-on-mutable reference by default.
parameter_def ->
  inferred_ref_arg: IDENTIFIER |
  inferred_ref_vararg: IDENTIFIER ELLIPSIS |
  arg: IDENTIFIER value_type |
  vararg: IDENTIFIER ELLIPSIS value_type

comma_parameter_defs ->
  add: comma_parameter_defs COMMA parameter_def |
  nil:

parameter_defs ->
  proper: parameter_def comma_parameter_defs |
  improper: parameter_def comma_parameter_defs COMMA

optional_parameter_defs ->
  parameter_defs |
  nil:

named_func_def<SourceDefinition> ->
  func_def: FUNC IDENTIFIER optional_generic_parameters LPAREN optional_parameter_defs RPAREN return_type statement_block |
  method_def: FUNC LPAREN parameter_def RPAREN IDENTIFIER optional_generic_parameters LPAREN optional_parameter_defs RPAREN return_type statement_block |
  alias: FUNC IDENTIFIER ASSIGN expression


anonymous_func_expr<Expression> ->
  FUNC LPAREN optional_parameter_defs RPAREN return_type statement_block

//
// Package definition =========================================================
//

// NOTE: the package name is taken from the directory name.  The compiler must
// ensure the directory name is a valid IDENTIFIER.  The name cannot be
// "internal" since that's special cased by go.  As an alternative to go's
// internal, if the package name is a private, it can only be accessed by its
// parent directory package.
package_def<SourceDefinition> ->
  no_spec: PACKAGE |
  with_spec: PACKAGE statement_block

%%lang_specs{
go:
  package: parser
  value_types:
    ParseError: "ParseErrorSymbol"
    Count: "TokenCount"
    Value: "TokenValue"
    Expression: "Expression"
    TypeExpression: "TypeExpression"
    Statement: "Statement"
    Statements: "[]Statement"
    SourceDefinition: "SourceDefinition"
    SourceDefinitions: "[]SourceDefinition"
    Argument: "*Argument"
    ArgumentList: "*ArgumentList"
  generate_end_pos: True
}%%
