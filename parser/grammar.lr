%token<CountSymbol> NEWLINES // (\n|\r\n)+

%token INTEGER_LITERAL FLOAT_LITERAL RUNE_LITERAL STRING_LITERAL

// _ is never a real identifier, and is only used as a variable or type
// placeholder.  Identifiers with prefix "_" are private to the package.
// nameing convention is lower camelcase for variables, upper camelcase for
// types.
%token<ValueSymbol> IDENTIFIER

%token TRUE FALSE

%token IF ELSE SWITCH CASE DEFAULT FOR DO IN
%token RETURN BREAK CONTINUE FALLTHROUGH

%token PACKAGE IMPORT AS

%token UNSAFE

%token TYPE IMPLEMENTS STRUCT ENUM TRAIT
%token FUNC ASYNC DEFER
%token VAR LET

%token NOT AND OR

%token<ValueSymbol> LABEL_DECL // <identifier>@
%token<ValueSymbol> JUMP_LABEL // @<identifier>

%token LBRACE RBRACE LPAREN RPAREN LBRACKET RBRACKET
%token DOT COMMA QUESTION SEMICOLON COLON EXCLAIM
%token DOLLAR_LBRACKET // $[
%token DOT_DOT_DOT // ...
%token TILDE_TILDE

%token ASSIGN

%token ADD_ASSIGN SUB_ASSIGN MUL_ASSIGN DIV_ASSIGN MOD_ASSIGN
%token ADD_ONE_ASSIGN SUB_ONE_ASSIGN
%token BIT_NEG_ASSIGN BIT_AND_ASSIGN BIT_OR_ASSIGN BIT_XOR_ASSIGN
%token BIT_LSHIFT_ASSIGN BIT_RSHIFT_ASSIGN

%token ADD SUB MUL DIV MOD
%token BIT_NEG BIT_AND BIT_XOR BIT_OR BIT_LSHIFT BIT_RSHIFT
%token EQUAL NOT_EQUAL LESS LESS_OR_EQUAL GREATER GREATER_OR_EQUAL

%token<ParseError> PARSE_ERROR

%start source package_def type_def named_func_def expression

source -> optional_definitions

optional_definitions ->
  NEWLINES |
  definitions: optional_newlines definitions optional_newlines |
  nil:

optional_newlines ->
  NEWLINES |
  nil:

definitions ->
  nil: definition |
  add: definitions NEWLINES definition

definition ->
  // There can only be one package_def per package
  package_def |
  type_def |
  named_func_def |
  global_var_def: var_decl_pattern |
  global_var_assignment: var_decl_pattern ASSIGN expression |
  // There can only be at most one statement_block per package, which act as
  // the package's init function
  statement_block

//
// Statement block
//

// IMPORTANT NOTE!!!
//
// The grammar is specified in such a way that only the statement_block rule
// uses LBRACE and RBRACE.  Hence, we can unconditionally parse a
// statement_block when we encounters a LBRACE.
//
// This enables the parser to parse the source in piecemeal manner, which
// enables the parser to collect more parse errors on a single run.
//
// Post analysis is needed to ensure statements are valid for the specific
// context.
//
// Note: statement_block's value type can be either the statement_block's
// real value type, or PARSE_ERROR's value type
statement_block -> LBRACE statements RBRACE

statements ->
  empty_list: |
  add: statements statement

statement ->
  implicit: statement_body NEWLINES |
  explicit: statement_body SEMICOLON

simple_statement_body ->
  unsafe_statement |

  expression_or_implicit_struct: expressions |

  // maybe allow pseudo-call such as struct initialization?
  //
  // NOTE: call_expr's access_expr and its arguments are evaluated immediately
  // Only the call itself is async.
  //
  // NOTE: Only applicable in expression blocks
  async: ASYNC call_expr |  // returns an await handler

  // Returns unit
  //
  // XXX: maybe make defer's call_expr run on the nearest scope exit rather
  // than on function scope exit.  Transpiling this semantic to golang would
  // be annoying since golang's defer operate on function rather than scope
  // exit.  Maybe just code gen the defer call on every exit point instead of
  // relying on golang's defer?
  //
  // Need to ensure this an actual function call, not a struct initialization.
  //
  // NOTE: call_expr's access_expr and its arguments are evaluated immediately.
  // Only the call itself is deferred.
  //
  // NOTE: Only applicable in expression blocks
  //
  // NOTE: compiler should optimize away the await handler if it's not used.
  defer: DEFER call_expr |


  // NOTE: Only applicable in expression blocks
  jump_statement: jump_type optional_jump_label optional_expressions |

  // NOTE: variable declaration without assignment is parsed as an expression.
  //
  // NOTE: package level assign pattern must be a var/let declaration
  assign_statement: assign_pattern ASSIGN expression |

  // NOTE: assignment can only operate on proper address values.  Additional
  // checks are applied during post analysis.
  //
  // NOTE: Only applicable in expression block
  unary_op_assign_statement: access_expr unary_op_assign |
  binary_op_assign_statement: access_expr binary_op_assign expression |

  // Only applicable to switch case block
  FALLTHROUGH

statement_body ->
  simple_statement_body |

  // NOTE: Only applicable to package_def
  import_statement |

  // NOTE: Only applicable to switch case block.
  // Post analysis is needed to associate statements to cases (move trailing
  // non-case statements into case's data structure).
  case_branch_statement: CASE case_patterns COLON optional_simple_statement_body |
  default_branch_statement: DEFAULT COLON optional_simple_statement_body

optional_simple_statement_body ->
  simple_statement_body |
  nil:

//
// Assign statements
//

unary_op_assign ->
  ADD_ONE_ASSIGN |
  SUB_ONE_ASSIGN

binary_op_assign ->
  ADD_ASSIGN |
  SUB_ASSIGN |
  MUL_ASSIGN |
  DIV_ASSIGN |
  MOD_ASSIGN |
  BIT_NEG_ASSIGN |
  BIT_AND_ASSIGN |
  BIT_OR_ASSIGN |
  BIT_XOR_ASSIGN |
  BIT_LSHIFT_ASSIGN |
  BIT_RSHIFT_ASSIGN

//
// Unsafe statement
//

// escape hatch to get a basic compiler/transpiler running.
// unsafe<go> "emit verbatim go source"
unsafe_statement -> UNSAFE LESS IDENTIFIER GREATER STRING_LITERAL

//
// Jump statement
//

jump_type ->
  RETURN |
  BREAK |
  CONTINUE

optional_jump_label ->
  JUMP_LABEL |
  unlabelled:

expressions ->
  expression |
  add: expressions COMMA expression

optional_expressions ->
  expressions |
  nil:

//
// Import statement
//

import_statement ->
  single: IMPORT import_clause |
  multiple: IMPORT LPAREN import_clauses RPAREN

import_clause ->
  STRING_LITERAL |
  alias: STRING_LITERAL AS IDENTIFIER

import_clause_terminal ->
  implicit: import_clause NEWLINES |
  explicit: import_clause COMMA

import_clauses ->
  first: import_clause_terminal |
  add: import_clauses import_clause_terminal

//
// Case statement
//

case_patterns ->
  case_pattern |
  multiple: case_patterns COMMA case_pattern

//
// Variable declaration pattern (Pseudo expression) ===========================
//

// VAR declares a reassignable variable. LET declares a non-reassignable
// variable.  A "constant" is a LET variable associated with a type with no
// public access to fields, and no mutation methods.
var_decl_pattern -> var_or_let var_pattern optional_value_type

var_or_let -> VAR | LET

var_pattern ->
  IDENTIFIER |
  tuple_pattern

tuple_pattern -> LPAREN field_var_patterns RPAREN

field_var_patterns ->
  field_var_pattern |
  add: field_var_patterns COMMA field_var_pattern

field_var_pattern ->
  positional: var_pattern |
  named: IDENTIFIER ASSIGN var_pattern |
  DOT_DOT_DOT

optional_value_type ->
  value_type |
  nil:

// NOTE: expression captures identifier and tuple vars, as well as fully
// evaluated expressions.  Additional post analysis checks are needed to
// reject invalid usage, depending on the context (e.g., assignment should
// only allow identifier expressions)
assign_pattern -> sequence_expr

case_pattern ->
  assign_pattern |

  // Note: parsing VAR <pkg>.<enum type>.<enum value>(...) is painful using
  // context free grammar (e.g, need to make VAR a prefix op expression instead
  // of var_decl_pattern), hence we won't support this form. (the expression
  // actually parses explicit enum match pattern, where VARs are inside the
  // data list, but we should reject this form for consistency)
  enum_match_pattern: DOT IDENTIFIER implicit_struct_expr |
  enum_var_decl_pattern: VAR DOT IDENTIFIER tuple_pattern

//
// Expressions ================================================================
//

expression ->
  if_expr: optional_label_decl if_expr |
  switch_expr: optional_label_decl switch_expr |
  loop_expr: optional_label_decl loop_expr |
  sequence_expr

optional_label_decl ->
  LABEL_DECL |
  unlabelled:

//
// Sequence control flow expression
//

sequence_expr ->
  or_expr |
  // NOTE: var_decl_pattern is not a real expression.  Unexpected usage in real
  // expressions are rejected during type checking.
  var_decl_pattern |
  // Case pattern need to disambiguate between using a variable for pattern
  // matching vs assigning a value to the variable (This is optional in
  // assign_pattern since it's unambiguous)
  assign_var_pattern: GREATER sequence_expr

//
// If control flow expression
//

// NOTE: label is applied to the entire if expression rather than individual
// branches.
if_expr ->
  no_else: IF condition statement_block |
  if_else: IF condition statement_block ELSE statement_block |
  multi_if_else: IF condition statement_block ELSE if_expr

condition ->
  sequence_expr |
  case: CASE case_patterns ASSIGN sequence_expr

//
// Switch control flow expression
//

// match patterns within the same case must all have identical variable binding

// Allow fallthrough iff the next case have identical (and fewer) variable
// bindings.
//
// e.g., OK.  y is binded to the same value
// switch val {
// case var (x, y): fallthrough
// case (_, var y): // do something
// }
//
// e.g., Not ok.  y != z
// switch val {
// case var (x, y): fallthrough
// case (_, var z): // do something
// }

// Switch need to be exhastive.
switch_expr -> SWITCH sequence_expr statement_block

//
// For control flow expression
//

// NOTE: Since we use {} for expression grouping, we need the extra DO keyword
// to help the parser figure out which block is the loop's body.
//
// For example, suppose the infinite loop grammar is "FOR body_expr" and
// the while loop grammar is "FOR sequence_expr body_expr".  Then the while
// loop can be interpreted as an infinite loop "FOR sequence_expr", followed by
// an sequence statement "body_expr".
loop_expr ->
  infinite: DO statement_block |
  do_while: DO statement_block FOR sequence_expr |
  while: FOR sequence_expr DO statement_block |
  iterator: FOR assign_pattern IN sequence_expr DO statement_block |
  for: FOR for_assignment SEMICOLON optional_sequence_expr SEMICOLON optional_sequence_expr DO statement_block

optional_sequence_expr ->
  sequence_expr |
  nil:

for_assignment ->
  sequence_expr |
  assign: assign_pattern ASSIGN sequence_expr

//
// Call expression
//

call_expr -> access_expr optional_generic_binding LPAREN optional_arguments RPAREN

optional_generic_binding ->
  binding: DOLLAR_LBRACKET optional_generic_arguments RBRACKET |
  nil:

optional_generic_arguments ->
  generic_arguments |
  nil:

// XXX allow named generic argument?
generic_arguments ->
  value_type |
  add: generic_arguments COMMA value_type

optional_arguments ->
  arguments |
  nil:

arguments ->
  argument |
  add: arguments COMMA argument

argument ->
  positional: expression |
  named: IDENTIFIER ASSIGN expression |
  colon_expressions |
  // NOTE: ... is not a real expression.  Unexpected usage in real expressions
  // are rejected during type checking.
  DOT_DOT_DOT

colon_expressions ->
  pair: optional_expression COLON optional_expression |
  add: colon_expressions COLON optional_expression

optional_expression ->
  expression |
  nil:

//
// Simple expressions (in decreasing order precedence)
//

// TODO cast
// TODO type isa check
// TODO is check
// TODO select (via trait instead of channel)
atom_expr ->
  literal |
  IDENTIFIER |
  block_expr: optional_label_decl statement_block |
  anonymous_func_expr |
  initialize_expr: initializable_type LPAREN arguments RPAREN |
  implicit_struct_expr |
  PARSE_ERROR

literal ->
  TRUE |
  FALSE |
  INTEGER_LITERAL |
  FLOAT_LITERAL |
  RUNE_LITERAL |
  STRING_LITERAL

implicit_struct_expr -> LPAREN arguments RPAREN

access_expr ->
  atom_expr |
  access: access_expr DOT IDENTIFIER |
  call_expr |
  index: access_expr LBRACKET argument RBRACKET

postfix_unary_expr ->
  access_expr |
  question: access_expr QUESTION

prefix_unary_op ->
  NOT |
  BIT_NEG |
  SUB |
  // "deref" copies an lvalue object.  The reference can be either mutable or
  // immutable.
  MUL |
  // "ref" returns a mutable reference to the lvalue object.  ref-ing can be
  // applied on either mutable or immutable referenced location.
  BIT_AND

prefix_unary_expr ->
  postfix_unary_expr |
  prefix_op: prefix_unary_op prefix_unary_expr

mul_op ->
  MUL |
  DIV |
  MOD |
  BIT_AND |
  BIT_LSHIFT |
  BIT_RSHIFT

mul_expr ->
  prefix_unary_expr |
  op: mul_expr mul_op prefix_unary_expr

add_op ->
  ADD |
  SUB |
  BIT_OR |
  BIT_XOR

add_expr ->
  mul_expr |
  op: add_expr add_op mul_expr

cmp_op ->
  EQUAL |
  NOT_EQUAL |
  LESS |
  LESS_OR_EQUAL |
  GREATER |
  GREATER_OR_EQUAL

cmp_expr ->
  add_expr |
  op: cmp_expr cmp_op add_expr

and_expr ->
  cmp_expr |
  op: and_expr AND cmp_expr

or_expr ->
  and_expr |
  op: or_expr OR and_expr

//
// Types ======================================================================
//

// Note: named type initializations are parsed as call_expr instead of
// initialize_expr
initializable_type ->
  explicit_struct_def |
  slice: LBRACKET value_type RBRACKET |  // shorthand for Slice$[ <value_type> ]
  array: LBRACKET value_type COMMA INTEGER_LITERAL RBRACKET |
  map: LBRACKET value_type COLON value_type RBRACKET // shorthand for Map$[ <value_type> , <value_type> ]

atom_type ->
  initializable_type |
  named: IDENTIFIER optional_generic_binding |
  extern_named: IDENTIFIER DOT IDENTIFIER optional_generic_binding |
  inferred: DOT optional_generic_binding |  // XXX: maybe use a different token symbol
  implicit_struct_def |
  explicit_enum_def |
  implicit_enum_def |
  trait_def |
  func_type |
  PARSE_ERROR

// NOTE: allowing return type to use trait algebra without explicitly wrapping
// inside a trait() would cause to ambiguity.  e.g.,
// "func() A + B" could mean func() returning "A + B" or "func() A" + "B"
returnable_type ->
  atom_type |
  optional: QUESTION returnable_type | // shorthand for Optional$[ <atom_type> ]
  result: EXCLAIM returnable_type | // shorthand for Result$[ <atom_type> ]
  reference: BIT_AND returnable_type |
  public_methods_trait: BIT_NEG returnable_type |  // type's public methods
  public_trait: TILDE_TILDE returnable_type  // type's public methods and fields

// NOTE: use explicit trait() to specify op precedence e.g.,
// trait( trait(A+B) * C)
value_type ->
  returnable_type |
  trait_intersect: value_type MUL returnable_type |
  trait_union: value_type ADD returnable_type |
  trait_difference: value_type SUB returnable_type

type_def ->
  definition: TYPE IDENTIFIER optional_generic_parameters value_type |
  constrained_def: TYPE IDENTIFIER optional_generic_parameters value_type IMPLEMENTS value_type |
  alias: TYPE IDENTIFIER ASSIGN value_type

//
// Generic parameter definition
//

// XXX: allow default generic parameter value?
generic_parameter_def ->
  unconstrained: IDENTIFIER |
  constrained: IDENTIFIER value_type

generic_parameter_defs ->
  generic_parameter_def |
  add: generic_parameter_defs COMMA generic_parameter_def

optional_generic_parameter_defs ->
  generic_parameter_defs |
  nil:

optional_generic_parameters ->
  generic: DOLLAR_LBRACKET optional_generic_parameter_defs RBRACKET |
  nil:

//
// Explicit/Implicit struct definition
//

field_def ->
  explicit: IDENTIFIER value_type |
  implicit: value_type |
  unsafe_statement

implicit_field_defs ->
  field_def |
  add: implicit_field_defs COMMA field_def

optional_implicit_field_defs ->
  implicit_field_defs |
  nil:

implicit_struct_def -> LPAREN optional_implicit_field_defs RPAREN

explicit_field_defs ->
  field_def |
  implicit: explicit_field_defs NEWLINES field_def |
  explicit: explicit_field_defs COMMA field_def

optional_explicit_field_defs ->
  explicit_field_defs |
  nil:

explicit_struct_def -> STRUCT LPAREN optional_explicit_field_defs RPAREN

//
// Explicit/Implicit enum definition
//

// NOTE: use "_" for field type denote no data associated with the  enum value.
enum_value_def ->
  field_def |
  default: field_def ASSIGN DEFAULT

// NOTE: inferred "<value_type> OR ()" should be treated as
// Optional$[<value_type>]
//
// NOTE: inferred "<value_type> OR Error" should be treated as
// Result$[<value_type>]
//
// NOTE: both inferred types "<value_type> OR Error or ()" and
// "<value_type> OR () OR Error" should be treated as
// Result$[ Optional$[ <value_type> ] ]
implicit_enum_value_defs ->
  pair: enum_value_def OR enum_value_def |
  add: implicit_enum_value_defs OR enum_value_def

implicit_enum_def -> LPAREN implicit_enum_value_defs RPAREN

explicit_enum_value_defs ->
  explicit_pair: enum_value_def OR enum_value_def |
  implicit_pair: enum_value_def NEWLINES enum_value_def |
  explicit_add: implicit_enum_value_defs OR enum_value_def |
  implicit_add: implicit_enum_value_defs NEWLINES enum_value_def

explicit_enum_def -> ENUM LPAREN explicit_enum_value_defs RPAREN

//
// Trait definition
//

trait_property ->
  field_def |
  method_signature

trait_properties ->
  trait_property |
  implicit: trait_properties NEWLINES trait_property |
  explicit: trait_properties COMMA trait_property

optional_trait_properties ->
  trait_properties |
  nil:

trait_def -> TRAIT LPAREN optional_trait_properties RPAREN

//
// Function type, definition, trait method signature
// and anonymous func expression
//

return_type ->
  returnable_type |
  nil:

parameter_decl ->
  arg: IDENTIFIER value_type |
  vararg: IDENTIFIER DOT_DOT_DOT value_type |
  unamed: value_type |
  unnamed_vararg: DOT_DOT_DOT value_type

parameter_decls ->
  parameter_decl |
  add: parameter_decls COMMA parameter_decl

optional_parameter_decls ->
  parameter_decls |
  nil:

func_type -> FUNC LPAREN optional_parameter_decls RPAREN return_type

// NOTE: FUNC is needed to disambiguate method signature from field def.
// e.g., Foo (int, int) could mean a field named Foo with type
// struct(int, int), or a method called Foo that takes two argument if func
// is not present.
//
// XXX: allow generic parameters in method signature? No, for go transpiler.
// Ideally yes.  We should allow function overloading as long as the functions
// all conforms to the same (unconstrainted) generic parameterized signature.
// Ambiguous usage would need to explicitly specify the generic parameter.
method_signature -> FUNC IDENTIFIER LPAREN optional_parameter_decls RPAREN return_type

// NOTE: Parameter that don't specify any value will be inferred as a mutable
// reference by default, i.e., equivalent to "&.".  Parameter that specify "."
// as its type will be inferred as copy-on-mutable reference by default.
parameter_def ->
  inferred_ref_arg: IDENTIFIER |
  inferred_ref_vararg: IDENTIFIER DOT_DOT_DOT |
  arg: IDENTIFIER value_type |
  vararg: IDENTIFIER DOT_DOT_DOT value_type

parameter_defs ->
  parameter_def |
  add: parameter_defs COMMA parameter_def

optional_parameter_defs ->
  parameter_defs |
  nil:

named_func_def ->
  func_def: FUNC IDENTIFIER optional_generic_parameters LPAREN optional_parameter_defs RPAREN return_type statement_block |
  method_def: FUNC LPAREN parameter_def RPAREN IDENTIFIER optional_generic_parameters LPAREN optional_parameter_defs RPAREN return_type statement_block |
  alias: FUNC IDENTIFIER ASSIGN expression


anonymous_func_expr ->
  FUNC LPAREN optional_parameter_defs RPAREN return_type statement_block

//
// Package definition =========================================================
//

// NOTE: the package name is taken from the directory name.  The compiler must
// ensure the directory name is a valid IDENTIFIER.  The name cannot be
// "internal" since that's special cased by go.  As an alternative to go's
// internal, if the package name is a private, it can only be accessed by its
// parent directory package.
package_def ->
  no_spec: PACKAGE |
  with_spec: PACKAGE statement_block

%%lang_specs{
go:
  package: parser
  value_types:
    ParseError: "ParseErrorSymbol"
    CountSymbol: "CountSymbol"
    ValueSymbol: "ValueSymbol"
}%%
